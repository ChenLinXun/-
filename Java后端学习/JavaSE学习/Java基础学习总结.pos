{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"note":"","watermark":"","lineStyle":{"lineColor":"#666","lineWidth":2},"children":[{"parent":"root","children":[{"parent":"cd08d5711703","children":[{"parent":"ab4b3287b500","children":[{"parent":"bbab4231096b","children":[],"id":"9c516d79f5b0","title":"1.&nbsp; 变量指值可变，或者引用的地址可变的数据类型；<br><br>2.&nbsp; 数据类型分为基本数据类型和引用类型<br><br>3.&nbsp; 基本数据类型指java八大基本数据类型，当基本类型不可变时，它的值就不能再修改<br><br>4.&nbsp; 引用类型包括对象、数组类型，引用类型是某个对象或数组的引用，保存的是对象或数组的地址，<br>&nbsp; &nbsp; &nbsp;当引用类型不可变时，意味的是它指向的数组或对象不可变（地址不可变），不能再重新指向一个新的对象或数组<br><br>5.&nbsp; 解释引用类型：<br>&nbsp; &nbsp; Person p1;&nbsp; //创建了一个Person类型的引用p1<br>&nbsp; &nbsp; p1 = new Person()；&nbsp; //将引用p1指向了一个新创建的Person对象&nbsp; &nbsp;&nbsp;<br><br>6.&nbsp;&nbsp;Java中，null是一个关键字，用来标识一个不确定的对象。<br>&nbsp; &nbsp; 因此可以将null赋给引用类型变量，但不可以将null赋给基本类型变量。"}],"collapsed":true,"id":"bbab4231096b","title":"介绍"},{"parent":"ab4b3287b500","children":[{"parent":"8f8440876bc7","children":[],"id":"e8d360b1acc6","title":"局部变量是定义在方法中或代码块中，使用时要赋初值，<br>如果不赋值就使用，编译会报错"},{"parent":"8f8440876bc7","children":[],"id":"7aa626ffcc96","title":"属性是指类的属性，如果不赋初值在类初始化时会为其赋初值，<br>所以即使不赋初值，也可以通过类对象调用属性，编译不报错"}],"collapsed":true,"id":"8f8440876bc7","title":"局部变量和属性"}],"collapsed":true,"id":"ab4b3287b500","title":"变量"},{"parent":"cd08d5711703","children":[{"parent":"2674a5c89fe6","children":[{"parent":"5610b915d367","children":[],"id":"36d21d22ff53","title":"数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。<br>数组是引用类型"}],"collapsed":true,"id":"5610b915d367","title":"基本概述"},{"parent":"2674a5c89fe6","children":[{"parent":"7acb01e883ef","children":[],"id":"c7bec07a6e4c","title":"1.&nbsp; 创建数组（new），JVM会在堆内存中开辟空间，存储数组对象<br><br>2.&nbsp; 数组在内存中会有自己的内存地址，以十六进制数表示<br><br>3.&nbsp; 数组变量（也就是数组类型引用）保存的是一个数组对象在内存中的地址，而不是一个具体数值，因此称为引用数据类型<br><br>4.&nbsp; 数组对象内容可以是基本数据类型，也可以是引用数据类型（也就是某个对象的地址）<br><br>5.&nbsp; 数组类型引用设置为final，意味着这个引用一旦指向了一个数组对象，那么就不能再指向别的数组了；<br>&nbsp; &nbsp; &nbsp;而指向的这个数组的内容是可以改变的，其内容可以是基本数据类型，也可以是引用数据类型（也就是某个对象的地址）"}],"collapsed":true,"id":"7acb01e883ef","title":"内存分布"},{"parent":"2674a5c89fe6","children":[{"parent":"7d447ba5ddda","children":[],"id":"31787f72661a","title":"数组定义和初始化方式：<br>方式一，静态初始化：<br>写法1.&nbsp; 数据类型[]&nbsp;数组名&nbsp;=&nbsp;new&nbsp;数据类型[]{元素1,元素2,元素3…};<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;（可拆分：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;数据类型[]&nbsp;数组名；<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;数组名&nbsp;=&nbsp;new&nbsp;数据类型[]{元素1,元素2,元素3…};）<br>写法2.&nbsp;&nbsp;数据类型[]&nbsp;数组名&nbsp;=&nbsp;{元素1,元素2,元素3…};<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;（不可拆分）<br><br>方式二，动态初始化：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 数据类型[]&nbsp;数组名&nbsp;=&nbsp;new&nbsp;数据类型[数组长度]；<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (可拆分：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;数据类型[]&nbsp;数组名；<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;数组名&nbsp;=&nbsp;new&nbsp;数据类型[数组长度]；)<br><br>"},{"parent":"7d447ba5ddda","children":[],"id":"cb99c159979a","title":"注意事项：<br>1.&nbsp; 数组使用时必须确定长度，一旦确定长度，长度就不能再修改<br>2.&nbsp; 数组内容类型必须和数组类型相同"}],"collapsed":true,"id":"7d447ba5ddda","title":"使用方式和注意事项"},{"parent":"2674a5c89fe6","children":[{"parent":"ae037d9bcbf7","children":[],"id":"1cd534f4994a","title":"动态初始化：<br>举例一：int[&nbsp;][&nbsp;]&nbsp;&nbsp;arr=new&nbsp;&nbsp;int&nbsp;[5][3];&nbsp;&nbsp;也可以理解为“5行3例”<br><br>举例二：int[&nbsp;][&nbsp;]&nbsp;myArray&nbsp;=&nbsp;new&nbsp;int[3][ ];<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;myArray[0]&nbsp;=&nbsp;new&nbsp;int[2];<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;myArray[1]&nbsp;=&nbsp;new&nbsp;int[1];<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;myArray[2]&nbsp;=&nbsp;new&nbsp;int[3];<br><br>静态初始化：<br>数据类型&nbsp;[&nbsp;][&nbsp;]&nbsp;&nbsp;&nbsp;数组名&nbsp;=&nbsp;{{元素1,元素2....},{元素1,元素2....},{元素1,元素2....}.....};<br><br>举例：int&nbsp;[&nbsp;][&nbsp;]&nbsp;&nbsp;arr={{22,15,32,20,18},{12,21,25,19,33},{14,58,34,24,66},};<br><br>"}],"collapsed":true,"id":"ae037d9bcbf7","title":"多维数组"}],"collapsed":true,"id":"2674a5c89fe6","title":"数组"}],"collapsed":false,"id":"cd08d5711703","title":"一、变量和数组"},{"parent":"root","children":[{"parent":"29d8f6ea1bf9","children":[],"id":"28a15fcb4df3","title":"顺序结构"},{"parent":"29d8f6ea1bf9","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineColor":"#555","lineWidth":1},"padding":"2px 9px 2px 9px","backgroundColor":"#4CAF50","color":"#FFFFFF","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","font-style":"normal"},"id":"bbc9449f7f3b","title":"分支结构"},{"parent":"29d8f6ea1bf9","children":[],"id":"17420316e260","title":"循环结构"}],"collapsed":false,"id":"29d8f6ea1bf9","title":"二、控制结构"},{"parent":"root","children":[{"parent":"80936f2484f2","children":[{"parent":"0069a653ba56","children":[],"id":"1e06d378a519","title":"以类的方式组织代码，以对象的方式组织（封装）数据<br>突出的编程思想：抽象"}],"collapsed":true,"id":"0069a653ba56","title":"面向对象编程的本质"},{"parent":"80936f2484f2","children":[{"parent":"b28e14f1d956","children":[{"parent":"588c9bb479fd","image":{"w":767,"h":170,"url":"http://cdn.processon.com/6166e1c7e401fd3c249730f4?e=1634136023&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:GF8jOCltwG8mvwCOT0yM43WLAlg="},"children":[],"id":"e964e50d485c","title":""}],"collapsed":true,"id":"588c9bb479fd","title":"四种访问权限"},{"parent":"b28e14f1d956","children":[{"parent":"d77d32f3d30b","children":[],"id":"8865f475e927","title":"类和接口的访问权限都只能是public的和default（不写访问权限修饰符就是默认）的"}],"collapsed":true,"id":"d77d32f3d30b","title":"类的访问权限"},{"parent":"b28e14f1d956","children":[{"parent":"f0558fbe5d80","children":[],"id":"32e87e71e784","title":"属性和方法的访问权限可以是四种访问权限之一"}],"collapsed":true,"id":"f0558fbe5d80","title":"属性、方法的访问权限"}],"collapsed":true,"id":"b28e14f1d956","title":"访问权限"},{"parent":"80936f2484f2","children":[{"parent":"05669f5d2c1e","children":[{"parent":"265333ae8a62","children":[],"id":"bad277b8ec6c","title":"1.\"高内聚，低耦合\"。高内聚就是类的内部数据操作细节自己完成，<br>&nbsp; &nbsp; 不允许外部干涉；低耦合就是仅暴露少量的方法给外部使用<br>2.&nbsp;数据的隐藏：通常应禁止直接访问一个对象中数据的实际表示，而<br>&nbsp; &nbsp; 应通过操作接口来访问，这称为信息隐藏<br>&nbsp;（从代码上简单来说就是：属性私有，get/set）"}],"collapsed":true,"id":"265333ae8a62","title":"封装的本质"},{"parent":"05669f5d2c1e","children":[{"parent":"4b218bcda09d","children":[],"id":"a18d1acf6e9c","title":"1.提高程序安全性，保护数据<br>2.隐藏代码的实现细节<br>3.统一接口<br>4.提高系统可维护能力"}],"collapsed":true,"id":"4b218bcda09d","title":"封装的好处"}],"collapsed":true,"id":"05669f5d2c1e","title":"封装"},{"parent":"80936f2484f2","children":[{"parent":"c166d79aff3d","children":[{"parent":"57bc3eea0abb","children":[{"parent":"47864f39751e","image":{"w":900,"h":364.3805309734513,"url":"http://cdn.processon.com/615472fa0e3e74663e9275b6?e=1632928011&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:XjQx9heMFJufzXa4P7zPGd1y1wE="},"children":[],"id":"a6509eaf40d8","title":"继承的jvm内存布局"}],"collapsed":true,"id":"47864f39751e","title":"当创建一个子类对象时，在jvm内存中，<br>第一步：首先在方法区根据该子类的继承关系，从最高父类开始加载类信息，依次加载至该子类的类信息<br>第二步：在堆里面为这个对象分配空间，然后在对象空间里也先从最高父类开始分配属性空间和方法空间，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;依次分配到该子类的属性空间和方法空间，最后在各属性空间中存储各属性值在常量池的地址（<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;指向常量池）<br>第三步：把该对象在堆里的地址返回给栈中main方法对该对象的引用（形成一个指向关系）"},{"parent":"57bc3eea0abb","children":[],"id":"af51679c5d35","title":"访问子类属性（方法）的规则---&gt;按照查找关系来返回信息：<br>（1）首先看子类是否有该属性（方法）<br>（2）如果子类有，并且可以访问，则返回该信息（调用此方法）<br>（3）如果子类没有，则看其父类有没有，如果有，并且可以访问，则返回该信息（调用此方法）<br>（4）如果父类没有，则按照（3）的规则继续向上级父类寻找，直到找到Object"}],"collapsed":true,"id":"57bc3eea0abb","title":"继承的本质"},{"parent":"c166d79aff3d","children":[{"parent":"596ce0bce539","children":[{"parent":"61e04862b5a2","children":[],"id":"4bfb97f6e96a","title":"1.子类继承了父类的所有属性和方法，但是父类的私有属性和方法不能在子类直接访问，<br>&nbsp; &nbsp;要通过公共的方法去访问"},{"parent":"61e04862b5a2","children":[],"id":"1dee71685784","title":"2.子类必须调用父类的构造器，完成父类的初始化（先有父亲才有儿子）"},{"parent":"61e04862b5a2","children":[],"id":"eb8e32ef77ce","title":"3.类不存在有参构造，无参构造没有显示定义（没写出来），则会默认存在一个无参构造，<br>一旦类存在有参构造，并且无参构造没有显示定义（没写出来），则类就没有无参构造<br>"},{"parent":"61e04862b5a2","children":[],"id":"8e652ddefe4a","title":"4.创建子类对象时，无论使用子类的哪一个构造器，都默认调用父类的无参构造器来初始化，<br>若父类没有无参构造器，则必须在子类构造器中用super()指定一个父类的构造器完成父类的<br>初始化工作，否则编译将不通过<br>（因此，创建一个类的有参构造时，最好把无参构造写上，避免其子类对象创建时无法找到<br>父类无参构造完成初始化而造成错误）"},{"parent":"61e04862b5a2","children":[],"id":"32b89fc25d51","title":"5.Java中所有的类都默认直接或间接继承Object类"},{"parent":"61e04862b5a2","children":[],"id":"937b7463b2c4","title":"6.子类最多只能继承一个父类，Java中是单继承机制"},{"parent":"61e04862b5a2","children":[],"id":"0735f7c13f8c","title":"7.不要滥用继承，必须满足is-a的逻辑关系"}],"collapsed":true,"id":"61e04862b5a2","title":"使用细节"},{"parent":"596ce0bce539","children":[{"parent":"7dbc76a3bf23","children":[{"parent":"43cea8c55357","children":[],"id":"f41789a16233","title":"1.访问父类属性：super.属性名<br>&nbsp; &nbsp;不能访问父类的private私有属性"},{"parent":"43cea8c55357","children":[],"id":"1a0a3cab06aa","title":"2.访问父类方法：super.方法名(参数列表)<br>&nbsp; &nbsp;不能访问父类的private私有方法"},{"parent":"43cea8c55357","children":[],"id":"ed4e6a3400c9","title":"3.访问父类构造器：super(参数列表)<br>只能在构造器中使用，并且必须放在第一行"}],"collapsed":true,"id":"43cea8c55357","title":"方法"},{"parent":"7dbc76a3bf23","children":[{"parent":"cf262241cdf5","children":[],"id":"20da4f710119","title":"1.当子类中有和父类成员重名时，为了访问父类的成员，必须通过super，<br>如果没有重名，那么使用super、this、直接访问，效果是一样的"},{"parent":"cf262241cdf5","children":[],"id":"2af4a62ee2e4","title":"2.super的访问不限于直接父类，如果多个上级父类（基类）都有重名的成员，<br>&nbsp; 那么super的访问采取就近原则"},{"parent":"cf262241cdf5","children":[],"id":"e5d967d1c1e3","title":"3.调用父类的构造器的好处：<br>分工明确，父类属性由父类构造器初始化，子类属性由子类构造器初始化"},{"parent":"cf262241cdf5","children":[{"parent":"9300172909a4","image":{"w":703,"h":357,"url":"http://cdn.processon.com/615abccef346fb69a723f502?e=1633340127&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:kzjoG0TPILHz2oaf8ffazK4io6c="},"children":[],"id":"8d12f470acee","title":""}],"collapsed":true,"id":"9300172909a4","title":"4.super和this的比较"}],"collapsed":true,"id":"cf262241cdf5","title":"细节"}],"collapsed":true,"id":"7dbc76a3bf23","title":"super的使用细节"},{"parent":"596ce0bce539","children":[{"parent":"e5a151c521db","children":[],"id":"c13910c0cfb7","title":"1.子类方法的方法名和参数必须和父类的完全一致"},{"parent":"e5a151c521db","children":[],"id":"dffc31818325","title":"2.子类方法的返回类型必须是父类方法的返回类型或是父类方法返回类型的子类型"},{"parent":"e5a151c521db","children":[],"id":"90864f10a6f1","title":"3.子类重写父类方法访问权限必须一致或是扩大，不能缩小"}],"collapsed":true,"id":"e5a151c521db","title":"方法重写细节"}],"collapsed":true,"id":"596ce0bce539","title":"继承使用细节总结"}],"collapsed":true,"id":"c166d79aff3d","title":"继承"},{"parent":"80936f2484f2","children":[{"parent":"ee531d5d056c","children":[{"parent":"7708968ccfd1","children":[{"parent":"93062f70dfcf","children":[],"id":"d15ffb55ad86","title":"父类的引用类型指向子类对象（即声明的是父类，实际指向的是子类的一个对象。）&nbsp;&nbsp;<br>Animal animal = new Cat();表示定义了一个Animal类型的引用，指向新建的Cat类型的对象"},{"parent":"93062f70dfcf","children":[{"parent":"aa1f26ef4d33","image":{"w":840,"h":393,"url":"http://cdn.processon.com/615aa55c7d9c087fb0df6fd0?e=1633334124&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:TR8A-3q3DxOBgS_UFkpESp2qCWg="},"children":[],"id":"9af5cd77e63a","title":""}],"collapsed":true,"id":"aa1f26ef4d33","title":"在JVM内存中：多态向上转型就是栈中的一个父类引用指向了堆中的实际的子类对象，<br>也就是说，这个实际的子类对象可以被多个父类指向"}],"collapsed":true,"id":"93062f70dfcf","title":"多态向上转型的本质"},{"parent":"7708968ccfd1","children":[{"parent":"285fd297101f","children":[],"id":"858203c551e3","title":"1.属性没有多态，没有重写之说，属性的值看编译类型"},{"parent":"285fd297101f","children":[],"id":"8ac6addce7cf","title":"2.等号左边是编译类型，等号右边是运行类型<br>&nbsp; &nbsp;换言之，等号左边的是一个引用类型，指向的是等号右边的实际对象"},{"parent":"285fd297101f","children":[],"id":"a37e91d8ab46","title":"3.一个对象的实际类型（等号右边）是确定的，但可以指向这个对象的引用的类型有很多，<br>可以是这对象实际类型的任意父类型。"},{"parent":"285fd297101f","children":[],"id":"78ceeb094f55","title":"4.Java动态绑定机制：<br>&nbsp;&nbsp;1.当调用对象方法时，该方法会和该对象的内存地址/运行类型进行绑定<br>&nbsp;&nbsp;2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用<br>&nbsp; 也就是说：当调用一个父类的引用的方法时，所调用的一定是此引用指向的<br>&nbsp; 实际对象的方法，这个方法若是重写了，那么运行重写后的这个方法，如果<br>&nbsp; 没有重写，那么使用继承下来的这个方法；<br>&nbsp; 注意！属性并不会与实际对象绑定，方法中所调用到的属性，在哪声明就在哪调用，<br>&nbsp; 比如调用了一个没有重写的方法时，进入到了父类里使用继承的方法，那么这个方法<br>&nbsp; 调用的属性在父类里声明了，就调用它；如果这个方法子类重写了，那么进入子类调用重写的方法，<br>&nbsp; 这个方法调用的属性在子类里声明了，就调用它"},{"parent":"285fd297101f","children":[],"id":"f99cbddccc07","title":"5.父类型指向了子类，可以调用父类中定义的所有属性和方法，但不能调用子类独有的方法&nbsp;，<br>&nbsp; &nbsp;除非进行强制转换，将父类型转换为子类型（高转低强制转换）"}],"collapsed":true,"id":"285fd297101f","title":"多态向上转型使用细节"}],"collapsed":true,"id":"7708968ccfd1","title":"多态的向上转型"},{"parent":"ee531d5d056c","children":[{"parent":"f370e3e8ebe8","children":[{"parent":"e7dd7e9b180b","children":[],"id":"1dcd6eecfa0f","title":"把一个指向子类对象的父类引用类型转换成了子类引用类型，Cat cat = (Cat)animal;<br>（也就是父类的引用变成了子类的引用，指向的还是原来的实际对象）"},{"parent":"e7dd7e9b180b","children":[{"parent":"e4a417bc5482","image":{"w":842,"h":394,"url":"http://cdn.processon.com/615aa55c7d9c087fb0df6fd0?e=1633334124&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:TR8A-3q3DxOBgS_UFkpESp2qCWg="},"children":[],"id":"ec819d3e177e","title":""}],"collapsed":true,"id":"e4a417bc5482","title":"在JVM内存中：多态向下转型就是：栈中一个指向子类对象的父类引用，转换出了一个<br>所指向堆中这个实际对象类型的引用，原来的这个父类引用仍然指向该子类对象"}],"collapsed":true,"id":"e7dd7e9b180b","title":"多态向下转型的本质"},{"parent":"f370e3e8ebe8","children":[{"parent":"c9263ec81b92","children":[],"id":"72d03e6bfe95","title":"1.只能强转父类的引用，不能强转父类的对象（也就是指向堆中的实际对象是无法改变的）"},{"parent":"c9263ec81b92","children":[],"id":"82a61e103c30","title":"2.要求父类引用强制转换的目标子类引用必须是这个父类引用所指向对象的类型<br>（也就是原本父类引用animal指向的是Cat类型对象，那么animal只能强转为Cat类型的引用）<br>（比如这个animal不能强转为Dog引用类型，因为猫和狗都是动物的子类但是彼此没有任何关系）<br>（这个animal也不能强转为Cat的子类类型，例如ChineseCat）<br>（总之，原本这个父类引用指向哪个子类对象，那么向下转型时就只能强转哪个子类对象的引用类型）"},{"parent":"c9263ec81b92","children":[],"id":"d2452ec2842f","title":"3.当向下转型后，可以调用子类类型的所有成员"}],"collapsed":true,"id":"c9263ec81b92","title":"多态向下转型使用细节"}],"collapsed":true,"id":"f370e3e8ebe8","title":"多态的向下转型"},{"parent":"ee531d5d056c","children":[{"parent":"1634b76ff6c3","children":[{"parent":"4f621c22964b","children":[],"id":"914aea6c0b5d","title":"定义：数组的定义类型为父类类型，里面保存的实际元素类型为子类类型"},{"parent":"4f621c22964b","children":[],"id":"b7861e8ff731","title":"用例：<br>Person[] persons = new Person[3];<br>persons[0] = new Person();<br>persons[1] = new Student();<br>persons[2] = new Teacher();"}],"collapsed":true,"id":"4f621c22964b","title":"1.多态数组"},{"parent":"1634b76ff6c3","children":[{"parent":"fbc02d7fbf01","children":[],"id":"ea347528de82","title":"定义：方法定义的形参类型为父类类型，实参允许为子类类型"},{"parent":"fbc02d7fbf01","children":[],"id":"e241fbbfca7a","title":"注意：当方法需调用某子类类型的特有方法时，注意需要将引用类型向下转型后调用<br>用例：<br>public void testWork(Employee e){<br>&nbsp; &nbsp; &nbsp; &nbsp;if(e&nbsp; instanceof Worker){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( (Worker) e).work; //向下转型操作<br>&nbsp; &nbsp; &nbsp; &nbsp;}<br>}"}],"collapsed":true,"id":"fbc02d7fbf01","title":"2.多态参数"}],"collapsed":true,"id":"1634b76ff6c3","title":"多态的应用"},{"parent":"ee531d5d056c","children":[{"parent":"999c41f0f8a5","children":[],"id":"0a54119eb6fe","title":"例：e instanceof Worker<br>前一个操作符是一个引用变量，后一个操作数通常是一个类（可以是接口），<br>用于判断前面的引用变量所指向的对象（也就是该引用的实际类型）是否是后面的类，或者其子类、实现类的实例。<br>如果是返回true，否则返回false。<br>使用条件：instanceof&nbsp;操作符的左右两边必须有继承或实现关系，否则编译报错"}],"collapsed":true,"id":"999c41f0f8a5","title":"instanceof运算符："}],"collapsed":true,"id":"ee531d5d056c","title":"多态"},{"parent":"80936f2484f2","children":[{"parent":"8d44cd8dbd2d","children":[{"parent":"ffe9bf3fb6d3","children":[{"parent":"d8d647d4cbf1","children":[],"id":"db1dc1f8d3d0","title":"解释main方法的形式：public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)<br>1.&nbsp; &nbsp;java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public<br>2.&nbsp; &nbsp;java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static<br>3.&nbsp; 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数<br>4.&nbsp; 一般情况下&nbsp;我们的main方法是不需要参数传入的，但是如果在工作中需要我们写一些小的应用程序，<br>&nbsp; &nbsp; 并且以jar包的方式发给其他人员直接在dos界面使用<br>"},{"parent":"d8d647d4cbf1","children":[{"parent":"45bf688cb839","image":{"w":615,"h":271,"url":"http://cdn.processon.com/616414f20e3e746edca3ab69?e=1633952514&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:unF86zwFlFAo5yUlcMQtvb0d1ao="},"children":[],"id":"d7fc49793946","title":""},{"parent":"45bf688cb839","image":{"w":608,"h":272,"url":"http://cdn.processon.com/6164155a7d9c086651310606?e=1633952618&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:ubeJrILSMmx41D9P8XEDmBgyp44="},"children":[],"id":"188441bba942","title":""}],"collapsed":true,"id":"45bf688cb839","title":"传args参数案例"}],"collapsed":true,"id":"d8d647d4cbf1","title":"main方法解释"},{"parent":"ffe9bf3fb6d3","children":[{"parent":"b118264c1649","children":[],"id":"344e0d885420","title":"语法：<br>（static）{<br>&nbsp; &nbsp; &nbsp; &nbsp;代码<br>&nbsp; &nbsp;}；//分号可省略"},{"parent":"b118264c1649","children":[],"id":"35520cb88504","title":"1.&nbsp; 代码块又称初始化块，在类加载时和创建对象时隐式调用，不能通过对象或类来显示调用<br>&nbsp; &nbsp; &nbsp;没有名字，没有参数，没有返回"},{"parent":"b118264c1649","children":[],"id":"ac4fa85019bf","title":"2.&nbsp; 唯一可修饰代码块的只有static关键字，修饰了static的为静态代码块，否则为普通代码块"},{"parent":"b118264c1649","children":[],"id":"8d1b0241ee31","title":"3.&nbsp; 好处：<br>&nbsp; &nbsp; &nbsp;1)相当于另外一种形式的构造器(对构造器的补充机制)，可以做初始化的操作<br>&nbsp; &nbsp; &nbsp;2)如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性"}],"collapsed":true,"id":"b118264c1649","title":"代码块和静态代码块"},{"parent":"ffe9bf3fb6d3","children":[{"parent":"e3e93f2c1f74","children":[{"parent":"c47b2ca1adbc","children":[],"id":"10854a22d299","title":"定义：类变量也称为静态变量，在类中以static关键字声明，但必须在方法、构造方法和语句块之外<br>定义了之后这个变量归这个类的所有对象共用"},{"parent":"c47b2ca1adbc","children":[],"id":"70b4ad633605","title":"内存解释：<br>存储位置：根据jdk版本的不同，类变量在jvm内存中的位置也不同<br>jdk8以前：一般认为类变量存储在方法区中，在加载类信息时，类变量的存储空间生成在了方法区的静态域中<br>jdk8以后：静态域存在于定义类的class对象中的尾部，所以一般认为类变量存储在类的class对象的最后，也就是在堆中<br><br>共享：静态变量不管放在哪，堆中对象的静态变量属性都指向同一个地址，就是这个静态变量存在的地址（因此形成共享）"}],"id":"c47b2ca1adbc","title":"定义和内存解释"},{"parent":"e3e93f2c1f74","children":[{"parent":"8e6da62d4a47","children":[],"id":"2dcf159defaa","title":"定义：在类中，且在方法、构造方法、语句块外定义的属性加上static修饰符"},{"parent":"8e6da62d4a47","children":[],"id":"f630c5debc2d","title":"使用：<br>&nbsp; &nbsp; &nbsp; &nbsp; 1.&nbsp; 类名.static属性&nbsp; &nbsp; &nbsp; 直接使用（规范，推荐）<br>&nbsp; &nbsp; &nbsp; &nbsp; 2.&nbsp; 对象名.static属性&nbsp; &nbsp;老方法使用"}],"collapsed":false,"id":"8e6da62d4a47","title":"使用方法"},{"parent":"e3e93f2c1f74","children":[{"parent":"fc2ccfb38bce","children":[],"id":"070fc60f7b15","title":"1.&nbsp; 需要每个类对象共用某个属性时可以使用"},{"parent":"fc2ccfb38bce","children":[],"id":"f65ea614b8a3","title":"2.&nbsp; 类变量共享，实例变量由各自对象实例独享"},{"parent":"fc2ccfb38bce","children":[],"id":"151e71a1d657","title":"3.&nbsp; 注意类变量也必须遵循访问权限机制"},{"parent":"fc2ccfb38bce","children":[],"id":"f8172b9dffe0","title":"4.&nbsp; 类变量在类加载时就初始化了（赋了初值，Java中没有赋值的变量时无法调用的），即使没有创建对象实例也可以用类名直接使用<br>&nbsp; &nbsp; 而普通变量必须在创建实例时（赋初值后）才能被使用"},{"parent":"fc2ccfb38bce","children":[],"id":"a39219699861","title":"5.&nbsp; 类变量的生命周期跟随类的加载开始 ，随着类的销毁而消亡"}],"id":"fc2ccfb38bce","title":"使用细节和注意事项"}],"collapsed":true,"id":"e3e93f2c1f74","title":"类变量/静态变量"},{"parent":"ffe9bf3fb6d3","children":[{"parent":"4ca056517af6","children":[{"parent":"2726cda222bc","children":[],"id":"4e2474e15ac4","title":"在类的方法前加上static修饰符，使用时：<br>1.&nbsp; 类名.静态方法名（规范，推荐）<br>2.&nbsp; 对象名.静态方法名"}],"collapsed":true,"id":"2726cda222bc","title":"使用"},{"parent":"4ca056517af6","children":[{"parent":"55becdeefa65","children":[],"id":"b1bac24e89b3","title":"1.&nbsp;&nbsp;类方法和普通方法一样都是将方法信息存储在方法区，类方法放在静态部分，普通方法放在非静态部分"},{"parent":"55becdeefa65","children":[],"id":"782770901104","title":"2.&nbsp; 类方法即使没有创建对象实例也可以用类名直接使用"},{"parent":"55becdeefa65","children":[],"id":"d79ec63eb62f","title":"3.&nbsp; 静态方法只能访问类的静态变量，并且只能调用类的静态方法（遵守访问权限）<br>&nbsp; &nbsp; &nbsp;普通方法可以调用静态变量和方法（遵守访问权限）<br>&nbsp; （加载有先后，类在内存中加载时静态方法是比普通方法先加载的）"},{"parent":"55becdeefa65","children":[],"id":"32b674a8b961","title":"4.&nbsp;&nbsp;静态方法当中不能用this、super关键字<br>&nbsp; （静态方法中没有this参数，而普通方法中是隐含的）<br>&nbsp; （或者说还是加载先后的问题，先加载静态方法，实例创建肯定在其后）"},{"parent":"55becdeefa65","children":[],"id":"8ebb3b7905ba","title":"5.&nbsp; 类方法不能被重写（覆盖）"},{"parent":"55becdeefa65","children":[],"id":"6bf5ed390f79","title":"6.&nbsp; 不管是静态方法还是普通方法，都不会因为实例的增多而增多，他们都是内存常驻的"}],"collapsed":true,"id":"55becdeefa65","title":"使用细节和注意事项"}],"collapsed":true,"id":"4ca056517af6","title":"类方法/静态方法"},{"parent":"ffe9bf3fb6d3","children":[{"parent":"ef4bdfcfb1db","children":[],"id":"3d1266b38de6","title":"1.&nbsp; 类什么时候被加载(重要!)<br>&nbsp; &nbsp; 1)创建对象实例时(new)&nbsp; //静态加载<br>&nbsp; &nbsp; 2)创建子类对象实例，父类也会被加载&nbsp; //静态加载<br>&nbsp; &nbsp; 3)使用类的静态成员时(静态属性,静态方法)&nbsp; //静态加载<br>&nbsp; &nbsp; 4)通过反射&nbsp;&nbsp;//动态加载"},{"parent":"ef4bdfcfb1db","children":[],"id":"91d4d82c9568","title":"2. 创建一个对象时，要调用类中哪些内容：<br>&nbsp; &nbsp;创建对象时类中会调用的只有：静态代码块、静态属性的初始化、普通代码块、普通属性的初始化、构造方法<br>"},{"parent":"ef4bdfcfb1db","children":[],"id":"38a79399d90c","title":"3.&nbsp; 创建一个对象时,在一个类调用顺序是（重点，难点）：<br>&nbsp; &nbsp; 1)调用静态代码块和静态属性初始化(注意:静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 的顺序调用)<br>&nbsp; &nbsp; 2)调用普通代码块和普通属性的初始化(注意:普通代码块和普通属性初始化调用的优先级一样,如果有多个普通代码块和多个普通属性初始化，则按定义顺&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 序调用)<br>&nbsp; &nbsp; 3)调用构造方法。<br><br>"},{"parent":"ef4bdfcfb1db","children":[],"id":"b3ab912a6db4","title":"4.&nbsp; 创建一个子类对象时，调用的顺序是（重点，难点）：<br>&nbsp; &nbsp;&nbsp;1)父类的静态代码块和静态属性(优先级一样,按定义顺序执行)<br>&nbsp; &nbsp; 2)子类的静态代码块和静态属性(优先级一样，按定义顺序执行)<br>&nbsp; &nbsp; 3)父类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)<br>&nbsp; &nbsp; 4)父类的构造方法<br>&nbsp; &nbsp; 5)子类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)<br>&nbsp; &nbsp; 6)子类的构造方法<br><br>&nbsp; &nbsp; &nbsp;解释：类的构造器中都隐含了super（）和普通代码块，super（）在第一行；所以父类构造器和子类的普通代码块及普通属性初始化优先子类构造器执行<br>"},{"parent":"ef4bdfcfb1db","children":[],"id":"a1f9dee2ff89","title":"5. 注意事项：<br>&nbsp; &nbsp; 1).&nbsp; 普通的代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 而静态代码块执行一次后就不再执行<br>&nbsp; &nbsp; 2).&nbsp; 如果只是使用类的静态成员时，普通代码块不会执行<br>&nbsp; &nbsp; 3).&nbsp; 静态代码块只能调用静态属性和静态方法，普通代码块可以调用任意成员"}],"collapsed":true,"id":"ef4bdfcfb1db","title":"类中信息随类的加载而执行的顺序"},{"parent":"ffe9bf3fb6d3","children":[{"parent":"86228738b168","children":[],"id":"9a4369b5cbea","title":"&nbsp;设计模式：单例模式（利用static修饰符，简单使用单例模式）<br>&nbsp;*&nbsp;单例模式---饿汉式：<br>&nbsp;*&nbsp;解释：<br>&nbsp;*&nbsp;单例模式是指希望某一个类最多只能有一个对象，不允许创建更多的对象<br>&nbsp;*&nbsp;饿汉式是指，当类被加载时（比如调用了类的静态属性或方法）这个对象就随之被创建，不管之后程序是否使用到这个对象<br>&nbsp;*&nbsp;设计方法：<br>&nbsp;*&nbsp;1.将构造器设置为private的，不允许直接new一个对象<br>&nbsp;*&nbsp;2.在类中创建这个类的静态对象并赋值引用，获取这个对象一定是通过静态方法获取，所以对象也必须是静态的<br>&nbsp;*&nbsp;3.设置一个静态方法返回这个唯一的对象的引用，只能通过类名调用，所以方法必须是静态的<br>&nbsp;*<br>&nbsp;*&nbsp;优点：饿汉式是线程安全的，不用考虑线程安全问题<br>&nbsp;*&nbsp;缺点：对象在类加载时被创建，可能造成资源浪费"},{"parent":"86228738b168","children":[],"id":"24629739d545","title":"&nbsp;设计模式：单例模式（利用static修饰符，简单使用单例模式）<br>&nbsp;*&nbsp;单例模式---懒汉式：<br>&nbsp;*&nbsp;解释：<br>&nbsp;*&nbsp;单例模式是指希望某一个类最多只能有一个对象，不允许创建更多的对象<br>&nbsp;*&nbsp;懒汉式是指，当类被加载时（比如调用了类的静态属性或方法）这个对象不会被创建，而是在调用获取对象的方法时才创建<br>&nbsp;*&nbsp;设计方法：<br>&nbsp;*&nbsp;1.将构造器设置为private的，不允许直接new一个对象<br>&nbsp;*&nbsp;2.在类中创建这个类的静态对象的引用但不赋值<br>&nbsp;*&nbsp;3.设置一个静态方法，做一个判断：当这个类对象为空时，创建这个唯一的对象(给引用赋值)，判断之外返回这个引用<br>&nbsp;*<br>&nbsp;*&nbsp;优点：类加载不会导致对象的创建，只有在调用获取对象的方法时创建，避免了资源浪费<br>&nbsp;*&nbsp;缺点：懒汉式是线程不安全的，在获取对象的方法处可能造成线程安全问题"}],"collapsed":true,"id":"86228738b168","title":"设计模式：单例模式"}],"collapsed":true,"id":"ffe9bf3fb6d3","title":"static_"},{"parent":"8d44cd8dbd2d","children":[{"parent":"c78a0ddb3e11","children":[{"parent":"e629ce2bba0f","children":[],"id":"4d946c26ee98","title":"final中文意思:最后的，最终的.<br>final可以修饰类、属性、方法和局部变量.<br>在某些情况下,程序员可能有以下需求,就会使用到final:<br>1)当不希望类被继承时,可以用final修饰.<br>2)当不希望父类的某个方法被子类覆盖/重写(override)时,可以用final关键字修饰。<br>3)当不希望类的的某个属性的值被修改,可以用final修饰.<br>（注意！如果修饰是基本类型，则是值不可修改；若是引用类型，则是引用不可修改）<br>4)当不希望某个局部变量被修改,可以使用final修饰<br>（注意！如果修饰是基本类型，则是值不可修改；若是引用类型，则是引用不可修改）<br>"}],"collapsed":true,"id":"e629ce2bba0f","title":"基本使用"},{"parent":"c78a0ddb3e11","children":[{"parent":"3c44ca07f902","children":[],"id":"1158335b9336","title":"1)&nbsp;final修饰的属性又叫常量,一般用xx_xx_xx来命名"},{"parent":"3c44ca07f902","children":[],"id":"30a1e7dcfe4a","title":"2)&nbsp;final修饰的成员属性必须赋初值,并且以后不能再修改，赋值可以在如<br>&nbsp; &nbsp; 下位置之一【选择一个位置赋初值即可】:<br>&nbsp; &nbsp; 1.定义时<br>&nbsp; &nbsp; 2.在构造器中<br>&nbsp; &nbsp; 3.在代码块中。<br>"},{"parent":"3c44ca07f902","children":[],"id":"f37d35b63fc8","title":"3)如果final修饰的成员属性是静态的，则初始化的位置只能是:<br>&nbsp; &nbsp;1.定义时<br>&nbsp; &nbsp;2.在静态代码块<br>&nbsp;（不能在构造器中赋值。）&nbsp;<br>"},{"parent":"3c44ca07f902","children":[],"id":"a1271414fed1","title":"4) final修饰的如果是基本类型，赋初值后，其值不可修改；<br>&nbsp; &nbsp; 如果是引用类型，则是该引用指向的对象不可修改（也就是引用的指向不可修改），<br>&nbsp; &nbsp; 但是对象内的值可修改，例如数组"},{"parent":"3c44ca07f902","children":[],"id":"38a47911e90c","title":"5)如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承"},{"parent":"3c44ca07f902","children":[],"id":"f10ecc764401","title":"6)如果一个类已经是final类了，它的方法就没必要再设置成final类型了，因为不会被继承就不会被重写"},{"parent":"3c44ca07f902","children":[],"id":"2e34b1d841f9","title":"7)final不能修饰构造器"},{"parent":"3c44ca07f902","children":[],"id":"e92443c3b16b","title":"8)final和static往往搭配使用，当调用被这两个修饰符修饰的成员时类不会被加载，效率更高，底层编译器做了优化处理"},{"parent":"3c44ca07f902","children":[],"id":"de891f8499ed","title":"9)许多包装类（例如Integer、Double、Float、String）都是final类"}],"collapsed":true,"id":"3c44ca07f902","title":"使用细节"}],"collapsed":true,"id":"c78a0ddb3e11","title":"final_"},{"parent":"8d44cd8dbd2d","children":[{"parent":"ef3959e4c27b","children":[],"id":"a6cb7f5365d8","title":"引出:<br>父类方法的不确定性：<br>当父类的某些方法需要声明但是还不知道怎么实现时，可以将此方法声明为抽象方法<br>则这个类就变成了抽象类，必须用abstract修饰<br>"},{"parent":"ef3959e4c27b","children":[{"parent":"a6ada1c98929","children":[],"id":"5692377c9231","title":"1. 用abstract修饰的类就是一个抽象类"},{"parent":"a6ada1c98929","children":[],"id":"02ef3172e9dd","title":"2. 用abstract修饰的方法就是抽象方法，抽象方法没有实现，也就是没有方法体（没有大括号）"},{"parent":"a6ada1c98929","children":[],"id":"9507adfbd6f5","title":"3. 抽象类的价值作用更多是在于设计，是设计者设计好后，让子类继承并实现"},{"parent":"a6ada1c98929","children":[],"id":"821381d76b5b","title":"4. 抽象类在框架和设计模式中用得很多"}],"collapsed":false,"id":"a6ada1c98929","title":"使用方法"},{"parent":"ef3959e4c27b","children":[{"parent":"f72f52670ae4","children":[],"id":"6b12f3c187e8","title":"1. 抽象类不能被实例化，但是可以有构造器"},{"parent":"f72f52670ae4","children":[],"id":"a0cbe37b1113","title":"2. 抽象类不一定包含抽象方法，可以没有抽象方法"},{"parent":"f72f52670ae4","children":[],"id":"622beb6eb893","title":"3. 一旦类包含了抽象方法，那么这个类必须声明为抽象类"},{"parent":"f72f52670ae4","children":[],"id":"b217d4ff50b1","title":"4. abstract只能修饰类和方法"},{"parent":"f72f52670ae4","children":[],"id":"2ce9f56e2f51","title":"5. 抽象类本质当然还是类，普通类可以有的东西抽象类都可以有"},{"parent":"f72f52670ae4","children":[],"id":"a4d82864d247","title":"6. 抽象方法不能实现方法也就是不能有方法体"},{"parent":"f72f52670ae4","children":[],"id":"ca17c45869bb","title":"7. 如果一个类继承了抽象类，则必须重写实现父类的所有抽象方法（有方法体，并且没有abstract修饰，方法体里可以不写东西）<br>&nbsp; &nbsp;否则也必须声明为抽象类"},{"parent":"f72f52670ae4","children":[],"id":"93462bcb3091","title":"8. 抽象方法不可以用private、static、final来修饰，因为这些都是和重写相违背的"}],"collapsed":true,"id":"f72f52670ae4","title":"使用细节和注意事项"},{"parent":"ef3959e4c27b","children":[{"parent":"83a659f01811","children":[],"id":"75707da7b7c2","title":"设计模式：模板模式（利用abstract修饰符，简单使用模板模式）<br>&nbsp;*&nbsp;解释：<br>&nbsp;*&nbsp;当多个类（需求）既有自己各自的功能，又都有需要一个相同的功能（比如计算某个方法工作的时间）时，<br>&nbsp;*&nbsp;为了不在各个类中重复地实现这个相同的功能<br>&nbsp;*&nbsp;可以参照（继承）一个模板类（抽象类），这个模板中已经包含了各个类都相同的方法，不需要重写<br>&nbsp;*&nbsp;又包含了抽象方法，供各个不同的类来实现，这个方法也就是各个类各自的功能<br><br>&nbsp;*&nbsp;设计方法：<br>&nbsp;*&nbsp;创建一个抽象类，设置抽象类中的公共方法，子类都继承且无需重写（子类相同的功能）<br>&nbsp;*&nbsp;设置抽象方法，子类都要实现，实现各自的功能"}],"collapsed":true,"id":"83a659f01811","title":"设计模式：模板模式"}],"collapsed":true,"id":"ef3959e4c27b","title":"abstract抽象类"},{"parent":"8d44cd8dbd2d","children":[{"parent":"ba4c7f6f5a87","children":[{"parent":"1771d3760225","children":[],"id":"9e00ee3a39d2","title":"接口就是一些没有实现的方法体封装到一起，当某些类要使用的时候，再根据具体情况，把他们实现出来<br>相当于是一个定义的规范或者契约"}],"collapsed":true,"id":"1771d3760225","title":"定义<br>"},{"parent":"ba4c7f6f5a87","children":[{"parent":"2ca43e757187","children":[],"id":"a57f6d127e60","title":"1. 接口声明的关键字是：interface"},{"parent":"2ca43e757187","children":[],"id":"911094312111","title":"2.一个类实现一个接口的关键字是：implements"}],"collapsed":true,"id":"2ca43e757187","title":"使用方法"},{"parent":"ba4c7f6f5a87","children":[{"parent":"db53216c97b4","children":[],"id":"5571ff4927ac","title":"1. 接口不能实例化，并且没有构造器"},{"parent":"db53216c97b4","children":[],"id":"c4aca26ab5e3","title":"2. 接口中的方法必须是public方法，可以不加public修饰"},{"parent":"db53216c97b4","children":[],"id":"ec4642dc6487","title":"3. 接口中的方法默认是抽象方法，没有方法体，可以不加abstract修饰"},{"parent":"db53216c97b4","children":[],"id":"7fd4646d4ed8","title":"4. jdk8以前接口中只能有抽象方法，不能有普通方法，也就是不能有方法的实现<br>&nbsp; &nbsp; jdk8和jdk8以后，接口中可以有普通方法和静态方法，但普通方法必须加default修饰符修饰<br>&nbsp; （default有违约的意思）"},{"parent":"db53216c97b4","children":[],"id":"3a766c32d2d6","title":"5. 普通类实现接口必须将接口的所有方法实现，抽象类实现接口可以不实现接口的方法<br>"},{"parent":"db53216c97b4","children":[],"id":"1a86d33dc009","title":"6.类实现了接口后，继承了接口的所有属性和方法"},{"parent":"db53216c97b4","children":[],"id":"105c3002457b","title":"7. 一个类可以同时实现多个接口，接口名之间用逗号隔开"},{"parent":"db53216c97b4","children":[],"id":"0b83eca2d870","title":"8. 接口中的属性默认必须是public static final的，所以必须赋初始值，这几个修饰符可以省略不写"},{"parent":"db53216c97b4","children":[],"id":"0e4ecad988c2","title":"9.接口中属性的调用方式是：接口名.属性名"},{"parent":"db53216c97b4","children":[],"id":"2ed52780257a","title":"10.接口不能继承extends其他的类，但是可以继承extends多个其他的接口"},{"parent":"db53216c97b4","children":[],"id":"0769e26d58a7","title":"11.接口的访问权限只能是public（公共）的和default（默认）的，这和类一样"}],"collapsed":true,"id":"db53216c97b4","title":"使用细节和注意事项"},{"parent":"ba4c7f6f5a87","children":[{"parent":"2a006c627287","children":[],"id":"74c4f2ce5b65","title":"从理解上来区别：<br>一个类继承了另一个类之后就有了与生俱来的能力，而它想再要其他的能力，不可能再继承另一个类了，<br>那么它可以通过实现接口的方式，来获得其他的能力，因为接口可以多个实现；所以接口可以理解为是<br>java单继承机制的一个普通机制<br>举一个老韩的例子：<br>一只猴子天生继承了猴子爸爸的爬树的本领，他只有一个爸爸，他的爸爸不会游泳和飞翔，它想学会游泳<br>和飞翔，于是实现了小鱼和小鸟提供的本领接口，它把这两个接口实现了，后天学会了游泳和飞翔"}],"collapsed":true,"id":"2a006c627287","title":"实现接口和继承类的区别"},{"parent":"ba4c7f6f5a87","children":[{"parent":"c270aa135de8","children":[],"id":"2db8f1711e9b","title":"类实现了接口后，接口的引用可以指向这个类的实例（向上转型），也可以将引用强转回实现类的引用（向下转型），<br>使用接口多态时，可以把接口想象为实现类的“父类”"},{"parent":"c270aa135de8","children":[],"id":"15e355637f61","title":"接口既然有多态，那么也可以使用多态参数、多态数组"},{"parent":"c270aa135de8","children":[],"id":"75de77c242dc","title":"接口多态传递：若一个接口A继承了另一个接口B，一个类实现了接口A，也相当于实现了接口B，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么接口B的引用也可以指向这个实现类"}],"collapsed":true,"id":"c270aa135de8","title":"接口多态"}],"collapsed":true,"id":"ba4c7f6f5a87","title":"interface接口"},{"parent":"8d44cd8dbd2d","children":[{"parent":"070271c7cbbe","children":[{"parent":"80bbf3208e23","children":[{"parent":"84e7613ed7e7","children":[{"parent":"bbb87ff1ea0d","children":[],"id":"e0ad667a0440","title":"在方法或代码块中直接写一个类"}],"collapsed":true,"id":"bbb87ff1ea0d","title":"使用方法"},{"parent":"84e7613ed7e7","children":[{"parent":"8ea6a0bd1419","children":[],"id":"d93d02d6bfb9","title":"1. 可以直接访问外部类的所有成员，包括私有的"},{"parent":"8ea6a0bd1419","children":[],"id":"66928ea960ca","title":"2.&nbsp; 本质仍然是一个类，地位相当于一个局部变量，不可以用访问修饰符修饰，可以用final修饰，因为局部变量可以被final修饰"},{"parent":"8ea6a0bd1419","children":[],"id":"25a014c2570e","title":"3. 作用域仅仅在所处的方法或代码块中，在这个方法或代码块以外的地方不可以访问"},{"parent":"8ea6a0bd1419","children":[],"id":"67b7f9e16595","title":"4. 所在的方法或代码块中可以创建这个局部内部类的对象，进行调用方法或访问成员"},{"parent":"8ea6a0bd1419","children":[],"id":"117da15c40a8","title":"5.&nbsp;若内部类成员和外部类成员重名，访问采取就近原则<br>&nbsp; &nbsp; 若仍想调用外部类成员时，可以这样使用：外部类名.this.外部成员<br>&nbsp; （外部类名.this 实际上就是调用了包含了这个内部类的方法的外部类对象）"}],"collapsed":true,"id":"8ea6a0bd1419","title":"使用细节和注意事项"}],"collapsed":true,"id":"84e7613ed7e7","title":"局部内部类（有类名）"},{"parent":"80bbf3208e23","children":[{"parent":"5037b3638982","children":[{"parent":"a50e554076d6","children":[],"id":"070cf6390f6a","title":"假如我们要实现一个接口来调用接口中的方法，或者要继承一个抽象类（普通类也一样）重写里面的方法并调用出来，并且只调用一次。<br>如果按传统模式，我们要写一个类来实现这个接口或者继承这个抽象类，实现或重写完里面的方法后，还要创建这个类的对象来调用想要调用的方法。<br>由于我们只需要调用这个方法一次，在这之后继承或实现的这个类就没有用了，那么这么做既浪费了一个类的空间，又显得繁琐，降低开发效率<br><br>那么这个时候匿名内部类就派上了用场：<br>jdk底层可以识别我们使用了匿名内部类的语法，自动创建了一个类来实现接口或继承类（这样我们就不用自己手写这个类来了），这个类只会使用一次，并且！返回一个实现类的对象（可以把“new&nbsp;接口”看成实现这个接口的类的对象）"}],"collapsed":true,"id":"a50e554076d6","title":"引出<br>"},{"parent":"5037b3638982","children":[{"parent":"1daebbc8f037","children":[],"id":"4d1c7d17c861","title":"接口：<br>new&nbsp;接口{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现方法；<br>}.要调用的方法();<br><br>也可以<br>接口&nbsp;接口引用&nbsp;=&nbsp;new&nbsp;接口{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现方法；<br>}；<br>接口引用.调用的方法()；<br>"},{"parent":"1daebbc8f037","children":[],"id":"0bafe157b53f","title":"抽象类：<br>new&nbsp;抽象类(类）{<br>&nbsp; &nbsp; &nbsp; &nbsp; 实现抽象方法；<br>}.要调用的方法();<br><br>也可以<br>抽象类 抽象类引用&nbsp;=&nbsp;new 抽象类{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现抽象方法；<br>}；<br>抽象类引用.调用的方法()；<br>"}],"collapsed":true,"id":"1daebbc8f037","title":"语法"},{"parent":"5037b3638982","children":[{"parent":"cb003aa4705a","children":[],"id":"359053e3d98f","title":"使用匿名内部类时，在语法上没有写实现类的名字，所以称它为匿名的，<br>但实际上系统在底层自动创建它时当然会分配一个名字给它，<br>它的名字是：外部类名$1&nbsp;（如果再写一个匿名内部类，那么这个匿名内部类被分配的名字就是：外部类名$2&nbsp;，以此类推）<br>它使用一次就消失了，所以不能new&nbsp;外部类名$1&nbsp;()"}],"collapsed":true,"id":"cb003aa4705a","title":"本质"},{"parent":"5037b3638982","children":[{"parent":"9137a368b6a4","children":[],"id":"5f677fb64ce4","title":"1. 在语法的大括号后面直接点调用方法出来，相当于没有用一个引用来接收这个对象"},{"parent":"9137a368b6a4","children":[],"id":"81bbf574ed4c","title":"2. 若使用了这个接口或者抽象类的引用来接受这个对象，<br>&nbsp; &nbsp; 那么此处相当于一个向上转型，因为接口和抽象类相当于<br>&nbsp; &nbsp; 实现类的父类，那么就产生了父类的引用指向子类的对象<br>"},{"parent":"9137a368b6a4","children":[],"id":"e074e16d5c1e","title":"3. 在调用方法时会使用动态绑定机制，调用的是对象的实际<br>&nbsp; &nbsp; 类型的方法，也就是实现类（实现后）的方法"},{"parent":"9137a368b6a4","children":[],"id":"7ec9dbcf5b89","title":"4. 只有在用引用接收了这个对象之后，才可以用final修饰这个引用<br>&nbsp; &nbsp; 因为\"new 接口()\"相当于一个对象，不是引用类型，没有声明，不能被修饰"},{"parent":"9137a368b6a4","children":[],"id":"73970bc2b811","title":"5. 其他的细节和注意事项和局部内部类一致"}],"collapsed":true,"id":"9137a368b6a4","title":"使用细节和注意事项"}],"collapsed":true,"id":"5037b3638982","title":"匿名内部类<br>(没有类名，重点)<br>"}],"collapsed":true,"id":"80bbf3208e23","title":"定义位置：<br>外部类的局部位置上<br>（方法、代码块）<br>"},{"parent":"070271c7cbbe","children":[{"parent":"51edd0e7fa85","children":[{"parent":"e5653a89cd02","children":[{"parent":"6c32b5e62bd8","children":[],"id":"7341f8e44b8d","title":"定义在外部类的成员位置上，并没有static修饰"}],"id":"6c32b5e62bd8","title":"定义"},{"parent":"e5653a89cd02","children":[{"parent":"98e5d75fd3de","children":[],"id":"c256897d6ddf","title":"1.&nbsp;可以直接访问外部类的所有成员包括私有的"},{"parent":"98e5d75fd3de","children":[],"id":"9b0a712ae96b","title":"2. 地位是一个成员属性，可以用访问修饰符修饰"},{"parent":"98e5d75fd3de","children":[],"id":"29c14c466bd0","title":"3. 作用域和外部类其他成员一样"},{"parent":"98e5d75fd3de","children":[],"id":"1f981cd12d71","title":"4. 外部类方法访问成员内部类属性和方法：先创建对象再访问"},{"parent":"98e5d75fd3de","children":[],"id":"38858a454000","title":"5. 外部其他类访问成员内部类（要遵守访问权限）：<br>&nbsp; &nbsp;方法一：<br>&nbsp; &nbsp;Outer&nbsp;outer&nbsp;=&nbsp;new&nbsp;Outer();<br>&nbsp; &nbsp;Outer.MemberInner&nbsp;memberInner&nbsp;=&nbsp;outer.new&nbsp;MemberInner();<br>&nbsp; &nbsp;可以合在一起写：<br>&nbsp; &nbsp;Outer.MemberInner&nbsp;memberInner =&nbsp;new&nbsp;Outer().new&nbsp;MemberInner();<br><br>&nbsp; &nbsp;方法二：<br>&nbsp; &nbsp;在外部类Outer中写一个可以返回一个memberInner实例的方法<br>&nbsp; &nbsp;Outer.MemberInner&nbsp;memberInner2&nbsp;=&nbsp;outer.getMemberInner();<br><br>"},{"parent":"98e5d75fd3de","children":[],"id":"53e67af146fd","title":"6. 若内部类成员和外部类成员重名，内部类访问时，访问采取就近原则<br>&nbsp; &nbsp; 若仍想调用外部类成员时，可以这样使用：外部类名.this.外部成员"}],"collapsed":true,"id":"98e5d75fd3de","title":"使用细节和注意事项"}],"collapsed":true,"id":"e5653a89cd02","title":"成员内部类（没有static修饰）"},{"parent":"51edd0e7fa85","children":[{"parent":"3a493393e886","children":[{"parent":"fa6765525f23","children":[],"id":"7f26d777c4cf","title":"定义在外部类的成员位置上，而且有static修饰"}],"collapsed":true,"id":"fa6765525f23","title":"定义"},{"parent":"3a493393e886","children":[{"parent":"013e55746219","children":[],"id":"bfc1f28fc4a5","title":"1. 可以直接访问外部类的所有静态成员包括私有的，非静态的不行"},{"parent":"013e55746219","children":[],"id":"cb4c1a686a4b","title":"2.&nbsp;地位是一个成员属性，可以用访问修饰符修饰"},{"parent":"013e55746219","children":[],"id":"25d931f35b71","title":"3.&nbsp;作用域和外部类其他成员一样"},{"parent":"013e55746219","children":[],"id":"79f9f5596bbd","title":"4.&nbsp;外部类方法访问成员内部类静态属性和静态方法：可以直接通过类名访问<br>&nbsp; &nbsp; 访问普通属性和方法：先创建对象再访问"},{"parent":"013e55746219","children":[],"id":"b5e0b889a276","title":"5. 外部其他类访问静态内部类（要遵守访问权限）：<br>&nbsp; &nbsp;方法一：<br>&nbsp; &nbsp;因为s_MemberInner是静态的，直接外部类点就行<br>&nbsp; &nbsp;Outer.s_MemberInner&nbsp;s_memberInner&nbsp;=&nbsp;new&nbsp;Outer.s_MemberInner();<br><br>&nbsp; &nbsp;方法二：<br>&nbsp; &nbsp;在外部类Outer中写一个可以返回一个s_memberInner实例的方法<br>&nbsp; &nbsp;Outer.s_MemberInner s_memberInner2 =&nbsp;outer.gets_MemberInner();<br>&nbsp; &nbsp;"},{"parent":"013e55746219","children":[],"id":"1f29f9427c19","title":"6. 若内部类成员和外部类成员重名，内部类访问时，访问采取就近原则<br>&nbsp; &nbsp; 若仍想调用外部类成员时，可以这样使用：外部类名.外部成员"}],"collapsed":true,"id":"013e55746219","title":"使用细节和注意事项"}],"collapsed":true,"id":"3a493393e886","title":"静态内部类（有static修饰）"}],"collapsed":true,"id":"51edd0e7fa85","title":"定义位置：<br>外部类的成员位置上"}],"collapsed":true,"id":"070271c7cbbe","title":"内部类"}],"collapsed":true,"id":"8d44cd8dbd2d","title":"OOP高级部分"}],"collapsed":false,"id":"80936f2484f2","title":"三、OOP"},{"parent":"root","children":[{"parent":"901ceabb9290","children":[{"parent":"b03eb009d7f9","children":[{"parent":"7bc6b397a16e","children":[],"id":"6d9342748f04","title":"枚举：枚是一个个的，举是列举。顾名思义枚举类就是列出一个个对象的类；<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 英文是：enumeration，通常简写为enum<br>应用场景：<br>当我们设计一个类，这个类只有固定的几个对象，不希望被修改，那么可以把这个类定义为枚举类<br>例如：设计一个季节类，一年四个季节，那么设计的初衷是这个类的对象只应该定义春夏秋冬四个<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 对象，不应该出现别的对象，更不能对春夏秋冬其中一个对象进行修改<br>定义枚举类有两种方法：<br>1. 自定义枚举类 2. 利用enum关键字创建枚举类"}],"collapsed":true,"id":"7bc6b397a16e","title":"枚举类的引出"},{"parent":"b03eb009d7f9","children":[{"parent":"5f321e351b2b","children":[],"id":"76e166fd78a0","title":"自定义枚举类的方法：<br>1. 构造器私有化，防止直接new<br>2. 不设置set方法，防止对象属性被修改，可以设置get，对象属性只读<br>3. 在枚举类中创建枚举类对象，用static、final修饰，同时使用实现底层优化<br>&nbsp; &nbsp; 获取时直接用枚举类名获取，并且不需要加载枚举类<br>4. 枚举类对象名字全字母用大写，常量的命名规范<br>"}],"collapsed":true,"id":"5f321e351b2b","title":"自定义枚举类"},{"parent":"b03eb009d7f9","children":[{"parent":"7a7cea1b01b1","children":[{"parent":"86edffb9fb75","children":[],"id":"b5f7f656ea96","title":"1. 用enum关键字替代class"},{"parent":"86edffb9fb75","children":[],"id":"b778a9ba0aed","title":"2. 常量对象定义语法：常量名(参数列表)，常量名用大写，规范"},{"parent":"86edffb9fb75","children":[],"id":"14c283507c85","title":"3. 将定义对象常量写在最前面，多个对象常量用逗号分隔"},{"parent":"86edffb9fb75","children":[],"id":"ab0047ce59a1","title":"4. 设置属性get方法，不设置set方法，只读"},{"parent":"86edffb9fb75","children":[],"id":"6bc0f422ff32","title":"5. 其他类获取枚举类对象时，直接用枚举类名访问"}],"collapsed":true,"id":"86edffb9fb75","title":"使用enum关键字实现方法"},{"parent":"7a7cea1b01b1","children":[{"parent":"7ecde97ea081","children":[],"id":"6b36dff7aa18","title":"1. 使用enum创建枚举类时，会隐式继承Enum类，<br>&nbsp; &nbsp; 并且这个枚举类默认是final的，可以在命令行中<br>&nbsp; &nbsp; 用javap命令反编译class文件来证实"},{"parent":"7ecde97ea081","children":[],"id":"3f596dc8708d","title":"2. 用语法：常量名(参数列表) 创建常量对象时，<br>&nbsp; &nbsp;必须知道用的哪个构造器创建，如果是无参构造器<br>&nbsp; &nbsp;可以省略括号"},{"parent":"7ecde97ea081","children":[],"id":"c16aa97b3a1c","title":"3. 常量对象的定义必须写在枚举类中的最前面"},{"parent":"7ecde97ea081","children":[],"id":"c2e7652d2d2b","title":"4. 常量对象默认是public static final的，<br>&nbsp; &nbsp;其他类获取枚举类对象时，直接用枚举类名访问"},{"parent":"7ecde97ea081","children":[],"id":"d385aebf4f03","title":"5. 由于用enum创建枚举类会隐式继承Enum类，<br>&nbsp; &nbsp; 所以不能再继承其他的类，但可以实现接口"}],"collapsed":true,"id":"7ecde97ea081","title":"使用细节和注意事项"},{"parent":"7a7cea1b01b1","children":[{"parent":"ce2aca9bd223","children":[],"id":"187ecc7e93bf","title":"由于用enum创建枚举类会继承Enum类，因此可以使用Enum类的一些成员方法"},{"parent":"ce2aca9bd223","children":[],"id":"53ab290df554","title":"toString()：重写了toString，返回枚举类对象常量的常量名"},{"parent":"ce2aca9bd223","children":[],"id":"46567a98f9ec","title":"name()：返回枚举类对象常量的常量名"},{"parent":"ce2aca9bd223","children":[],"id":"0ed8514de2d2","title":"ordinal()：返回枚举对象常量的次序（编号，从零开始编）"},{"parent":"ce2aca9bd223","children":[],"id":"9c38e66a8494","title":"values()：是静态方法，返回枚举类数组，包含所有枚举对象（这个方法在反编译中可以看到）"},{"parent":"ce2aca9bd223","children":[],"id":"442e9f6a5b0f","title":"valueOf(String name)：是静态方法，根据字符串name找到与其匹配的枚举对象常量并返回"},{"parent":"ce2aca9bd223","children":[],"id":"6e2f6c6ac303","title":"compareTo(枚举类对象常量)：比较两个枚举对象常量的编号，<br>返回值是：括号外对象常量的编号减括号内的对象常量的编号"}],"collapsed":true,"id":"ce2aca9bd223","title":"Enum类成员方法的使用"}],"collapsed":true,"id":"7a7cea1b01b1","title":"enum枚举类"}],"collapsed":true,"id":"b03eb009d7f9","title":"枚举"},{"parent":"901ceabb9290","children":[{"parent":"ef3af22601ff","children":[{"parent":"3c44389d28ec","children":[],"id":"b752ee9c725e","title":"1. 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。"},{"parent":"3c44389d28ec","children":[],"id":"743914728f34","title":"2. 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。"},{"parent":"3c44389d28ec","children":[],"id":"751584c3850d","title":"3. 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能,忽略警告等。<br>&nbsp; &nbsp; 在JavaEE中注解占据了更重要的角色，例如用来配置应用程序的任何切面，<br>&nbsp; &nbsp; 代替java&nbsp;EE旧版中所遗留的繁冗代码和XML配置等。"}],"collapsed":true,"id":"3c44389d28ec","title":"注解的理解"},{"parent":"ef3af22601ff","children":[{"parent":"783b0420c80c","children":[{"parent":"9e3027b5b7f8","children":[],"id":"3480de940f4b","title":"1.&nbsp;@Override用于为重写的方法注解，只能用于方法"},{"parent":"9e3027b5b7f8","children":[],"id":"535fd161681e","title":"2. 使用@Override注解和不使用的区别：<br>&nbsp; &nbsp; 使用了@Override注解，编译器会检查是否真的重写了方法，否则编译不通过<br>&nbsp; &nbsp; 如果不使用，即使没有重写也不会报错，编译器会认为是一个新的方法"}],"collapsed":true,"id":"9e3027b5b7f8","title":"@Override 注解"},{"parent":"783b0420c80c","children":[{"parent":"cbb1431b026f","children":[],"id":"3d7498718a3e","title":"1. 修饰某个元素，表示某个元素已经过时了，但仍然可以使用<br>&nbsp; &nbsp; 可以修饰的元素有：方法、类、字段、包、参数，等等"},{"parent":"cbb1431b026f","children":[],"id":"5076c7866c55","title":"2. 使用意义：用于新旧版本的兼容和过渡"}],"collapsed":true,"id":"cbb1431b026f","title":"@Deprecated 注解"},{"parent":"783b0420c80c","children":[{"parent":"675fc77019b8","children":[],"id":"0b33c977ba57","title":"1. 当不希望看到一些警告信息时，可以使用@SuppressWarnings({\"\"}）注解来抑制警告信息"},{"parent":"675fc77019b8","children":[],"id":"c1100a41860f","title":"2.&nbsp;@SuppressWarnings({\"\"}) 注解，双引号中的参数有很多，可以抑制某些特定的警告，<br>&nbsp; &nbsp; 例如填入参数 all 则可抑制所有警告"},{"parent":"675fc77019b8","children":[],"id":"5436b1d91cfd","title":"3. 作用范围与所写的位置和填入的参数相关"}],"collapsed":true,"id":"675fc77019b8","title":"@SuppressWarnings({\"\"}) 注解"}],"collapsed":true,"id":"783b0420c80c","title":"JDK内置的基本注解"},{"parent":"ef3af22601ff","children":[{"parent":"061c12908863","children":[],"id":"6428928b4b7b","title":"元注解是修饰注解的注解，有以下四个种类：<br>"},{"parent":"061c12908863","children":[],"id":"e1f5feed0eea","title":"@Retention注解：只能用于修饰一个Annotation定义，用于指定该Annotation的生命周期<br>使用时为其value成员变量赋值，其值有以下三种：<br>1.&nbsp;RetentionPolicy.SOURCE:&nbsp;在源文件（.java文件），即源文件中保留，编译时期注解将被丢弃。<br>2. RetentionPolicy.CLASS:&nbsp;在class文件中有效，即.class文件中保留。当JVM解释.class字节码时，<br>&nbsp; &nbsp;不会保留该注解。这是默认策略。<br>3.&nbsp;RetentionPolicy.RUNTIME:&nbsp;在运行时有效，即运行时保留。当运行Java程序时，JVM会保留注解，<br>&nbsp; &nbsp;Java程序可以通过反射获取该注解。"},{"parent":"061c12908863","children":[],"id":"7e75d016b645","title":"@Target注解：用于修饰Annotation定义，指定被修饰的Annotation能用于修饰哪些程序元素<br>使用时为其value成员变量赋值，包含哪些值，所修饰的注解就可以注解到对应的地方"},{"parent":"061c12908863","children":[],"id":"9eb1bbdfd48b","title":"@Documented注解：&nbsp;用于指定被该元注解修饰的Annotation类将被javadoc工具提取成文档。<br>默认情况下，javadoc是不包括注解，@Documented注解必须要和策略为RUNTIME的@Retention注解一起使用。"},{"parent":"061c12908863","children":[],"id":"81faac630228","title":"@Inherited注解：被它修饰的Annotation将具有继承性。<br>如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。"}],"collapsed":true,"id":"061c12908863","title":"四种元注解（了解即可）"},{"parent":"ef3af22601ff","children":[{"parent":"62010de6d72c","children":[],"id":"c7877967b393","title":"在JavaEE中，注解扮演了很重要的角色，可以代替繁琐的xml配置，<br>以及配置程序的切面（在Spring的学习中会了解到）。<br>注意：<br>如果要在程序运行时获取某个类所标注的注解，进行业务流程，那么<br>这个注解必须要标注元注解：@RetentionPolicy.RUNTIME"},{"parent":"62010de6d72c","children":[{"parent":"92f75d2d819c","children":[],"id":"f4d9a6e6e76a","title":"语法：<br>public @Interface 注解名{<br>&nbsp;&nbsp;&nbsp; 属性类型 属性名() default 默认值;<br>}<br>"},{"parent":"92f75d2d819c","children":[],"id":"acc658d6ec51","title":"示例：<br>@Retention(RetentionPolicy.RUNTIME)<br>@Target(ElementType.TYPE)<br>public&nbsp;@interface&nbsp;Animal&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;type()&nbsp;default&nbsp;\"\";<br>}"},{"parent":"92f75d2d819c","children":[],"id":"221caaa436b3","title":"获取注解中属性值：<br>注解对象.注解属性名()；<br><br>示例：<br>annotation.type();"}],"collapsed":true,"id":"92f75d2d819c","title":"自定义注解<br>"},{"parent":"62010de6d72c","children":[{"parent":"30c3518068a2","children":[],"id":"8717c23d2fa9","title":"1. 如果注解标注在类上，则先利用反射，获取类的Class类对象：getClass() / Class.forName()<br>"},{"parent":"30c3518068a2","children":[],"id":"6f95a823f720","title":"2. 如果注解标注在方法、方法参数、类属性上，则利用该类的class对象获取这些成分：api见反射笔记<br>"},{"parent":"30c3518068a2","children":[],"id":"dc69a4a13265","title":"3. 根据注解标注的成分的对象，可调用以下有关注解的api：<br><br>&nbsp;&nbsp;&nbsp; boolean&nbsp;isAnnotationPresent(Class&lt;?extends&nbsp;Annotation&gt;&nbsp;annotationClass)<br>&nbsp;&nbsp;&nbsp;&nbsp;判断该程序元素上是否包含指定类型的注解<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;T&nbsp;extends&nbsp;Annotation&gt;&nbsp;T&nbsp;getAnnotation(Class&lt;T&gt;&nbsp;annotationClass)<br>&nbsp;&nbsp;&nbsp;&nbsp;返回该程序元素上存在的、指定类型的注解<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Annotation[]&nbsp;getAnnotations()<br>&nbsp;&nbsp;&nbsp;&nbsp;返回该程序元素上存在的所有注解。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;T&nbsp;extends&nbsp;Annotation&gt;&nbsp;T[]&nbsp;getAnnotationsByType(Class&lt;T&gt;&nbsp;annotationClass)<br>&nbsp;&nbsp;&nbsp;&nbsp;返回该程序元素上存在的、指定类型的注解数组。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;T&nbsp;extends&nbsp;Annotation&gt;&nbsp;T&nbsp;getDeclaredAnnotation(Class&lt;T&gt;&nbsp;annotationClass)<br>&nbsp;&nbsp;&nbsp;&nbsp;返回直接存在于此元素上的所有注解。该方法将忽略继承的注解。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;T&nbsp;extends&nbsp;Annotation&gt;&nbsp;T[]&nbsp;getDeclaredAnnotationsByType(Class&lt;T&gt;&nbsp;annotationClass)<br>&nbsp;&nbsp;&nbsp;&nbsp;返回直接存在于此元素上的所有注解。该方法将忽略继承的注解<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Annotation[]&nbsp;getDeclaredAnnotations()<br>&nbsp;&nbsp;&nbsp;&nbsp;返回直接存在于此元素上的所有注解及注解对应的重复注解容器。该方法将忽略继承的注解<br>"},{"parent":"30c3518068a2","children":[],"id":"9af661705435","title":"示例：<br>自定义注解：<br>@Retention(RetentionPolicy.RUNTIME)<br>@Target(ElementType.TYPE)<br>public&nbsp;@interface&nbsp;Animal&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;type()&nbsp;default&nbsp;\"\";<br>}<br>获取某个对象所属类标注的注解：<br>public void doResolve(Object&nbsp;obj)&nbsp;{<br>&nbsp;&nbsp;&nbsp; //先拿到该对象的class对象<br>&nbsp;&nbsp;&nbsp; Class&lt;?&gt;&nbsp;objClass&nbsp;=&nbsp;obj.getClass();<br>&nbsp;&nbsp;&nbsp; //获取标注在该类上的@Animal注解对象<br>&nbsp;&nbsp;&nbsp; Animal&nbsp;annotation&nbsp;=&nbsp;objClass.getAnnotation(Animal.class);<br>&nbsp;&nbsp;&nbsp; //输出注解中的属性值<br>&nbsp;&nbsp;&nbsp; System.out.println(annotation.type());<br>}"}],"collapsed":true,"id":"30c3518068a2","title":"获取类（类方法、方法参数、类属性）上的注解<br>"}],"collapsed":true,"id":"62010de6d72c","title":"获取注解与自定义注解<br>"}],"collapsed":true,"id":"ef3af22601ff","title":"注解"}],"collapsed":false,"id":"901ceabb9290","title":"四、枚举和注解"},{"parent":"root","children":[{"parent":"ef616e1bd932","children":[{"parent":"c1c84f8418a3","children":[],"id":"9a8ef499a7d6","title":"基本概念：<br>Java语言中，将程序执行中发生的不正常情况称为“异常”。(开发过程中的语法错误和逻辑错误不是异常)<br>执行过程中所发生的异常事件可分为两类：<br>1)&nbsp;Error(错误)：Java虚拟机无法解决的严重问题。如:JVM系统内部错误、资源耗尽等严重情况。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 比如:&nbsp;StackOverflowError[栈溢出]和OOM(out&nbsp;of&nbsp;memory).&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Error是严重错误，程序会崩溃。<br>2)&nbsp;Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 例如：空指针访问，访问不存在的文件，网络连接中断等等。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exception&nbsp;分为两大类：运行时异常和编译时异常"}],"collapsed":true,"id":"c1c84f8418a3","title":"异常的概念"},{"parent":"ef616e1bd932","children":[{"parent":"659a3e5d8ac8","children":[{"parent":"d6d21dc36410","children":[{"parent":"f9f7aa1362da","children":[],"id":"63f73eed7885","title":"1.&nbsp; NullPointerException空指针异常<br>2.&nbsp; ArithmeticException数学运算异常<br>3.&nbsp; ArraylndexOutOfBoundsException数组下标越界异常<br>4.&nbsp; ClassCastException类型转换异常<br>5.&nbsp; NumberFormatException数字格式不正确异常"}],"collapsed":true,"id":"f9f7aa1362da","title":"程序运行时发生的异常<br>有以下五大运行异常"}],"collapsed":true,"id":"d6d21dc36410","title":"运行异常"},{"parent":"659a3e5d8ac8","children":[{"parent":"2695ec86a06f","children":[],"id":"bcc0d0e2fdf5","title":"源代码在编译过程中出现的异常"}],"collapsed":true,"id":"2695ec86a06f","title":"编译异常"},{"parent":"659a3e5d8ac8","children":[{"parent":"aecf56ecbafb","image":{"w":342,"h":457,"url":"http://cdn.processon.com/616c2c9c0e3e7406e2043213?e=1634482861&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:QTy2mZjTC-Q0gI11hrvszXECvAY="},"children":[],"id":"6db3f15ca51f","title":""},{"parent":"aecf56ecbafb","image":{"w":650,"h":751,"url":"http://cdn.processon.com/616c2d087d9c08665140eacc?e=1634482968&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:XYMkpfcvR_LAw-ECgwkO0SfEQKk="},"children":[],"id":"897fa637e7a4","title":""}],"collapsed":true,"id":"aecf56ecbafb","title":"体系图"}],"collapsed":true,"id":"659a3e5d8ac8","title":"异常的分类和体系图"},{"parent":"ef616e1bd932","children":[{"parent":"617b7cdbc4f2","children":[{"parent":"4a5ecb3c45c4","children":[],"id":"c2b882d663e0","title":"程序编译运行过程中，如果发生了异常会使程序崩溃，退出运行，<br>当遇到不算致命的问题时，就导致程序崩溃，这是很不好的，所以<br>java设计者提供了异常处理机制，当异常发生时，可以通过异常处<br>理机制保证程序的正常执行"}],"collapsed":true,"id":"4a5ecb3c45c4","title":"异常处理的意义"},{"parent":"617b7cdbc4f2","children":[{"parent":"fb01530c2ad0","children":[{"parent":"71c80084e59e","children":[{"parent":"4acd03203004","children":[],"id":"15835416c6aa","title":"try{<br><br>//可能出现异常的代码<br><br>}catch(Exception e){<br><br>//捕获到异常<br>//1.当异常发生时，系统<br>&nbsp; &nbsp;将异常封装成Exception<br>&nbsp; &nbsp;对象e，传递给catch块<br>//2.得到异常对象后，程序<br>&nbsp; &nbsp;员自己处理，如果没发生<br>&nbsp; &nbsp;异常，则catch块不执行<br><br>}finally{<br><br>//不管是否发生异常，都执<br>&nbsp; &nbsp;行finally块中的代码，做<br>&nbsp; &nbsp;善后动作（例如关闭资源）<br><br>}"}],"collapsed":true,"id":"4acd03203004","title":"基本语法"},{"parent":"71c80084e59e","children":[{"parent":"d9128a88ed66","children":[],"id":"5020e8f2976c","title":"1.&nbsp; 在try中如果异常发生了，异常发生后面的代码不会执行，直接进入catch块"},{"parent":"d9128a88ed66","children":[],"id":"7cc797901b3a","title":"2.&nbsp; 如果异常没有发生则顺序执行try不会进入catch"},{"parent":"d9128a88ed66","children":[],"id":"cab85794d542","title":"3.&nbsp; 不管是否发生异常，都会执行finally"},{"parent":"d9128a88ed66","children":[],"id":"5ac50eef7072","title":"4.&nbsp; 可以有多个catch来捕获可能发生的多个异常，要求父类异常写在子类异常之后<br>&nbsp; &nbsp; &nbsp;如果发生了异常，只会匹配一个catch"},{"parent":"d9128a88ed66","children":[],"id":"ea4639dfda57","title":"5.&nbsp; 也可以进行try-finally配合使用，相当于没有捕获异常，发生异常时程序会奔溃，<br>&nbsp; &nbsp; &nbsp;但会做一些善后工作或业务逻辑。一些底层代码会这样使用"}],"collapsed":true,"id":"d9128a88ed66","title":"使用细节"}],"collapsed":false,"id":"71c80084e59e","title":"1.&nbsp; try-catch-finally<br>&nbsp; （程序员在代码中捕获发生的异常,自行处理）"},{"parent":"fb01530c2ad0","children":[{"parent":"7d689aed0963","children":[{"parent":"9c2945f8f9a1","children":[],"id":"a0871ec87a20","title":"1.&nbsp; 如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何<br>&nbsp; &nbsp; &nbsp;处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些<br>&nbsp; &nbsp; &nbsp;异常进行处理,而由该方法的调用者负责处理。<br>&nbsp; &nbsp;（最终的调用者、处理者是jvm，jvm会直接打印出异常然后停止程序）<br>2.&nbsp; 在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异<br>&nbsp; &nbsp; &nbsp;常类型可以是方法中产生的异常类型，也可以是它的父类。"}],"collapsed":true,"id":"9c2945f8f9a1","title":"基本使用"},{"parent":"7d689aed0963","children":[{"parent":"46135fe1ec0f","children":[],"id":"1cebec4b4b77","title":"1.&nbsp; 对于编译异常，程序中必须处理，比如try-catch&nbsp;或者throws<br>2.&nbsp; 对于运行时异常，程序中如果没有处理，默认就是throws的方式处理<br>3.&nbsp; 子类重写父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要<br>&nbsp; &nbsp; &nbsp;么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型<br>4.&nbsp; 在throws过程中，如果有方法&nbsp;try-catch，就相当于处理异常,就可以不必throws<br>"}],"collapsed":true,"id":"46135fe1ec0f","title":"使用细节"}],"collapsed":false,"id":"7d689aed0963","title":"2.&nbsp; throws<br>&nbsp; &nbsp;（将发生的异常抛出，交给调用者(方法)来处<br>&nbsp; &nbsp; &nbsp; 理，最顶级的处理者就是JVM）"}],"collapsed":true,"id":"fb01530c2ad0","title":"异常处理的方法"}],"collapsed":true,"id":"617b7cdbc4f2","title":"异常的处理"},{"parent":"ef616e1bd932","children":[{"parent":"6987ffe9ae76","children":[{"parent":"38e8a1b19a7c","children":[],"id":"de67f1f527ea","title":"当程序中出现了某些“错误”，但该错误信息并没有在Throwable子类中描述处理，<br>这个时候可以自己设计异常类，用于描述该错误信息。"}],"collapsed":true,"id":"38e8a1b19a7c","title":"基本概念"},{"parent":"6987ffe9ae76","children":[{"parent":"6419d24f4d07","children":[],"id":"ae1195b280a1","title":"1.&nbsp; 定义类：自定义异常类名(程序员自己写)继承Exception或RuntimeException<br>2.&nbsp; 如果继承Exception,属于编译异常<br>3.&nbsp; 如果继承RuntimeException，属于运行异常<br>&nbsp; &nbsp; (一般来说，继承RuntimeException，好处是可以使用默认的处理机制)<br>"}],"collapsed":true,"id":"6419d24f4d07","title":"自定义步骤"}],"collapsed":true,"id":"6987ffe9ae76","title":"自定义异常"},{"parent":"ef616e1bd932","children":[{"parent":"b7eae328d1a6","children":[],"id":"536660153f52","title":"throws：<br>使用在方法声明处，抛出的是异常的类型，给方法调用者处理，可能发生异常"},{"parent":"b7eae328d1a6","children":[],"id":"83607b1d3e35","title":"throw：<br>使用在方法体内，抛出的是具体的异常对象，给方法调用者处理，用throw说明一定发生了异常<br>如果这个异常是非运行异常，（非运行异常没有默认处理机制）则需要在方法申明时加上该异常的抛出，<br>即需要加上&nbsp;throws&nbsp;语句<br>"}],"collapsed":true,"id":"b7eae328d1a6","title":"throw和throws的对比"}],"collapsed":false,"id":"ef616e1bd932","title":"五、异常和处理"},{"parent":"root","children":[{"parent":"c552c0131d9d","children":[{"parent":"6d30135abd25","children":[{"parent":"42c3e00ea16b","children":[{"parent":"158fff084474","children":[],"id":"7fcf13136550","title":"==运算符：<br>1.既可以判断基本类型也可以判断引用类型<br>2.如果判断的是基本类型，则判断值是否相等<br>3.如果判断的是引用类型，则判断地址是否相等，<br>&nbsp; &nbsp;也就是看是不是地址相同的同一个对象"},{"parent":"158fff084474","children":[],"id":"9fb020b207ca","title":"equals()：<br>1.是Object类的方法，只能用于判断引用类型<br>2.默认判断的是地址是否相等，子类往往会重写这个方法，<br>&nbsp; 判断内容是否相等，比如：integer、String"}],"collapsed":true,"id":"158fff084474","title":"== 和 equals()的区别"},{"parent":"42c3e00ea16b","children":[{"parent":"bdbbb5eed178","children":[],"id":"aea03745fedb","title":"1.&nbsp; 如果判断两个对象是否“重复”的逻辑，不使用Object类的默认判断地址的逻辑<br>&nbsp; &nbsp; &nbsp;而是根据设计者设计的逻辑进行判断，例如：比较对象的某些字段相同表示重复<br>&nbsp; &nbsp; &nbsp;那么应该重写equals()方法"},{"parent":"bdbbb5eed178","children":[],"id":"8902c0706768","title":"2.&nbsp; 如果重写了equals()方法，那么通常应该重写hashCode的方法，<br>&nbsp; &nbsp; &nbsp;在Object类equals()方法的注释里说明了：<br>&nbsp; &nbsp; &nbsp;每当重写此方法时，通常都需要重写hashCode方法，<br>&nbsp; &nbsp; &nbsp;以维护hashCode方法的一般约定，即相等的对象必须具有相等的哈希码"},{"parent":"bdbbb5eed178","children":[],"id":"4e76bf9e53a2","title":"3.&nbsp; 对于第2点的解释：<br>&nbsp; &nbsp; &nbsp;3.1&nbsp; 如果重写了equals()方法的对象，不是具有哈希结构的集合的元素，那么一般可以不重写hashCode()方法<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 也就是说，这个不是硬性要求，不是编译上的问题，不按这样做也不会编译不通过<br>&nbsp; &nbsp; &nbsp;3.2&nbsp; 如果重写了equals()方法的对象，是具有哈希结构的集合的元素，那么就一定要重写hashCode()方法，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 否则可能出现严重的逻辑错误（也不是编译上的错误），这个严重的逻辑错误是：很可能会向哈希结构的<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 集合中添加了逻辑上“重复”的元素，而哈希结构的集合是不允许元素重复的"}],"collapsed":true,"id":"bdbbb5eed178","title":"equals()方法注意事项"}],"collapsed":true,"id":"42c3e00ea16b","title":"equals()方法"},{"parent":"6d30135abd25","children":[{"parent":"86ad4a913425","children":[],"id":"138853051a63","title":"1.&nbsp; 两个引用，如果指向的是地址相同的同一个对象，则哈希值肯定是一样的"},{"parent":"86ad4a913425","children":[],"id":"f34fcc0d1fa1","title":"2.&nbsp; 两个引用，如果指向的是地址不同的两个对象，则哈希值一般是不一样的，一样的概率很小很小"},{"parent":"86ad4a913425","children":[],"id":"b00d30cfe003","title":"3.&nbsp; 哈希值是根据对象的内部地址转换成一个整数实现的，但是不能等价于地址号，java语言不需要这种实现技巧"},{"parent":"86ad4a913425","children":[],"id":"61ff505ac743","title":"4.&nbsp; 如果对象所属的类重写了hashCode()方法，那么对象的hashCode值不再是默认的根据地址计算得出，<br>&nbsp; &nbsp; &nbsp;而是根据设计者的逻辑计算出hashCode值，例如：<br>&nbsp; &nbsp; &nbsp;String类中重写了equals()和hashCode()方法：&nbsp;<br>&nbsp; &nbsp; &nbsp;比较两个String对象的底层字符数组value的每一个字符，<br>&nbsp; &nbsp; &nbsp;如果相同，则equals()返回true，hashCode()返回相同的hashCode值"},{"parent":"86ad4a913425","children":[],"id":"cb2d13016ae2","title":"5.&nbsp; 在集合中，如果有需要也会重写hashCode方法，提高具有哈希结构的容器的效率"},{"parent":"86ad4a913425","children":[],"id":"7e77fa8228de","title":"6.&nbsp; 所以综上所述判断两个对象是否“重复”，不能简单的用其hashCode值区分；<br>&nbsp; &nbsp; 若要判断两个对象是否为地址相同的对象，应该用“==”运算符比较"}],"collapsed":true,"id":"86ad4a913425","title":"hashCode()方法"},{"parent":"6d30135abd25","children":[{"parent":"5468fd50ba78","children":[],"id":"23d12f7f7c48","title":"1.默认返回全类名（包名加类名）+@+对象哈希值的十六进制"},{"parent":"5468fd50ba78","children":[],"id":"81cbf5e3d66a","title":"2.子类往往会重写toString方法，用于返回对象的属性信息"},{"parent":"5468fd50ba78","children":[],"id":"7eb53c62c83d","title":"3.输出一个对象时，toString默认被调用"}],"collapsed":true,"id":"5468fd50ba78","title":"toString()方法"},{"parent":"6d30135abd25","children":[{"parent":"9555c86d2339","children":[],"id":"63ac5e6fa1bf","title":"1.当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写finalize方法做一些释放资源的操作"},{"parent":"9555c86d2339","children":[],"id":"91618c0e9d04","title":"2.什么时候被回收：当某个对象没有任何引用时，则jvm就会认为这个对象是个垃圾对象，就会使用垃圾回收机制<br>&nbsp; &nbsp;来销毁该对象，在销毁之前会调用finalize方法"},{"parent":"9555c86d2339","children":[],"id":"b9a9fadeaeae","title":"3.垃圾回收机制的调用是由系统来决定的（即有自己的GC算法），也可以通过System.gc() 来主动触发垃圾回收机制"},{"parent":"9555c86d2339","children":[],"id":"07275bd170b5","title":"（提示：实际开发中几乎不会运用finalize方法，最多只是应付面试）"}],"collapsed":true,"id":"9555c86d2339","title":"finalize()方法"}],"collapsed":true,"id":"6d30135abd25","title":"Object类"},{"parent":"c552c0131d9d","children":[{"parent":"e6c40ab73fc1","children":[],"id":"4bbe38a54b71","title":"根据八种基本数据类型相应的引用类型<br>有了类的特点就可以调用类的方法"},{"parent":"e6c40ab73fc1","children":[{"parent":"11a449e20081","children":[],"id":"50c85e2e2b86","title":"1.&nbsp; Boolean类&nbsp; --&gt; boolean<br>2.&nbsp; Character类&nbsp;--&gt; char<br>3.&nbsp; Byte类&nbsp;--&gt; byte<br>4.&nbsp; Short类&nbsp;--&gt; short<br>5.&nbsp; Integer类&nbsp;--&gt; int<br>6.&nbsp; Long类&nbsp;--&gt; long<br>7.&nbsp; Floath&nbsp;--&gt; float<br>8.&nbsp; Double&nbsp;--&gt; double"},{"parent":"11a449e20081","children":[],"id":"85623fdb8e3d","title":"Boolean和Character直接继承Object，没有继承Number<br>其他六大包装类都继承了Number"}],"collapsed":true,"id":"11a449e20081","title":"八大wrapper类"}],"collapsed":true,"id":"e6c40ab73fc1","title":"包装类"},{"parent":"c552c0131d9d","children":[{"parent":"791e0601cd54","children":[{"parent":"ed2f77660928","children":[{"parent":"de76d6a268c2","children":[],"id":"101e008f897c","title":"1.&nbsp;&nbsp;String类表示字符串常量。&nbsp;Java&nbsp;程序中的所有字符串文字，例如 \"abc\"，都是作为String类的实例实现的。<br>"},{"parent":"de76d6a268c2","children":[],"id":"8a3541963f79","title":"2.&nbsp; &nbsp;为什么说String类型是字符串常量？解释：&nbsp;<br>&nbsp; &nbsp; &nbsp; jdk8下在String类的底层，保存字符序列的，实际上是字符数组，jdk9后是字节数组，<br>&nbsp; &nbsp; &nbsp; 这两个数组的名字都是value，value是final类型，说明这个value数组的地址不可改变，<br>&nbsp; &nbsp; &nbsp; 虽然value数组的内容可变，但String类中没有设计改变String对象value属性内容的方法。<br>&nbsp; &nbsp; &nbsp; 所以说String类对象是不可变对象，被称为字符串常量，或字符串常量对象"},{"parent":"de76d6a268c2","children":[],"id":"b936e253ac12","title":"3.&nbsp; 字符串对象是不可变对象，一旦字符串对象被分配，其内容就不可改变：<br>&nbsp; &nbsp; &nbsp;(1)&nbsp; Java设计者很小心地设计保护了String类中封装的数据，也就是字符串，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;不提供能修改String对象内容的方法，所有如replace()修改字符串的方法，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;实际都是返回了一个新建的String对象，而不是真正的修改原来的String对象。<br>&nbsp; &nbsp; &nbsp;(2)&nbsp; 而像：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s1 = \"aa\";<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s1 = \"bb\"；<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;的“修改”方式，实际上是在字符串常量池中新建了\"bb\"字符串对象，让s1指向<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;它而已，则此时\"aa\"对象已经没有引用指向它了<br>&nbsp; &nbsp;（3）因此字符串对象一旦创建，则之后的修改操作都是创建另一个新的字符串对象<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 注意：除非使用反射暴破！"},{"parent":"de76d6a268c2","children":[],"id":"831aea4e77e5","title":"4.&nbsp; String类较常用构造方法(其它看手册):<br>&nbsp; &nbsp; &nbsp;new String();<br>&nbsp; &nbsp; &nbsp;new&nbsp;String&nbsp;(String&nbsp;original);<br>&nbsp; &nbsp; &nbsp;new&nbsp;String(char[]&nbsp;a);<br>&nbsp; &nbsp; &nbsp;new&nbsp;String(char[]a,int&nbsp;startIndex,int&nbsp;count);"},{"parent":"de76d6a268c2","children":[],"id":"cba303ca0e82","title":"5.&nbsp;&nbsp;String类中重写了equals()和hashCode()方法：<br>&nbsp; &nbsp; &nbsp;比较两个String对象的底层字符数组value的每一个字符，<br>&nbsp; &nbsp; &nbsp;如果相同，则equals()返回true，hashCode()返回相同的hashCode值"}],"collapsed":true,"id":"de76d6a268c2","title":"String结构剖析"},{"parent":"ed2f77660928","children":[{"parent":"173f8ed35ec1","children":[],"id":"a1487ae6f821","title":"1.&nbsp; jdk1.6下，字符串池存放在jvm内存的方法区的永久代中；jdk1.7之后，字符串池存放在堆中，并且永久代被废除了"},{"parent":"173f8ed35ec1","children":[],"id":"4edfc9df33ef","title":"2.&nbsp; 字符串池中存放的实际上还是字符串对象的引用，jdk1.7以前字符串池引用的对象放在方法区中，之后放到了堆中；<br>&nbsp; &nbsp; &nbsp;现在普遍使用jdk1.7上的版本，所以为了区分堆中被字符串池引用的对象和直接在堆中创建被其他地方引用的对象，<br>&nbsp; &nbsp; &nbsp;以下均称堆中被字符串池引用的对象为字符串池中的对象"},{"parent":"173f8ed35ec1","children":[],"id":"659622e4a28e","title":"3.&nbsp; 当直接对一个String类型赋值时，会先在字符串池中寻找是否存在和这个值相同的String对象，如果没有，则在字符串池中创建这个对象，<br>&nbsp; &nbsp; &nbsp;然后返回这个对象的引用；若寻找成功，则直接返回这个引用。<br>&nbsp; &nbsp; &nbsp;结论是这样的赋值方法可能创建0或1个对象"},{"parent":"173f8ed35ec1","children":[],"id":"20e011c3dcd6","title":"4.&nbsp; 当使用new&nbsp;String(String)创建String对象时，先在字符串常量池中创建一个对象，<br>&nbsp; &nbsp; &nbsp;如果池中已经存在和其值相同的对象则不用创建，然后在堆中创建这个对象的副本，并返回。<br>&nbsp; &nbsp; &nbsp;结论是用这样的赋值方法可能创建1或2个对象"},{"parent":"173f8ed35ec1","children":[],"id":"68ef103df507","title":"5.&nbsp; String是不可变对象，只要创建就不能修改，所有的修改操作实际上都会创建新的String对象，若修改方式如：<br>&nbsp; &nbsp; &nbsp;a = \"b\";则相当于在字符串常量池创建新的String对象并指向它，若已存在则直接返回引用<br>"},{"parent":"173f8ed35ec1","children":[],"id":"6d536a1c9698","title":"6.&nbsp; &nbsp;若是字面量加号相连的方式构建，编译器会优化，相当于在池中创建：<br>&nbsp; &nbsp; &nbsp; String s = \"AA\" + \"BB\"; <br>&nbsp; &nbsp; &nbsp;优化后相当于：String&nbsp;s&nbsp;=&nbsp;\"AABB\";<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;若是对象加号相连的方式构建，则会先创建一个StringBuilder再append<br>&nbsp; &nbsp; &nbsp;String a = \"a\";&nbsp;<br>&nbsp; &nbsp; &nbsp;String b =&nbsp;\"b\";<br>&nbsp; &nbsp; &nbsp;String t =&nbsp;a + b;<br>&nbsp; &nbsp; &nbsp;优化后相当于：在堆中创建对象“ab”，然后返回，不会在池中创建<br><br>&nbsp; &nbsp; &nbsp;结论：若创建和拼接方式中没有出现某个字符串的字面量，那么创建<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;这个字符串对象时不会在池中创建，直接在堆中创建并返回引用"},{"parent":"173f8ed35ec1","children":[],"id":"47a0566d743c","title":"7.&nbsp; 额外注意的是，在jdk1.7废除了永久代后，String的intern()方法也做了相应修改：<br>&nbsp; &nbsp; &nbsp;jdk1.7以前：inter()方法是在字符串池中寻找内容相同的对象，并返回引用，若找不到会在字符串池中创建并返回；<br>&nbsp; &nbsp; &nbsp;jdk1.7后：inter()方法在字符串池中找不到的话，若堆中存在和其值相同的String对象，会在字符串池中留下这个<br>&nbsp; &nbsp; 堆对象的引用，并返回；也就是说若此后再以直接赋值的方式创建这个值的String对象都会在池中发现这个引用并<br>&nbsp; &nbsp; 返回（指向了堆中的String对象），而不会再创建常量对象然后返回常量对象的引用了"},{"parent":"173f8ed35ec1","children":[{"parent":"928989b7d199","image":{"w":475,"h":171,"url":"http://cdn.processon.com/6163ce27e0b34d7c7da62454?e=1633934391&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:VFyIA75O_VUz0naperXR4T2lYcw="},"children":[{"parent":"fc2e2a1d9541","image":{"w":626,"h":298,"url":"http://cdn.processon.com/6163ce12f346fb06a9e27c80?e=1633934370&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:OFJwC_taZOANrkKsKizeNxrH_3o="},"children":[],"id":"9fc984edac58","title":""},{"parent":"fc2e2a1d9541","image":{"w":627,"h":317,"url":"http://cdn.processon.com/6163ce91e401fd3c248edb12?e=1633934497&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:NEEkXs35afYxNSAeoJ7BGR_97mc="},"children":[],"id":"4149d9d839a8","title":""}],"collapsed":true,"id":"fc2e2a1d9541","title":"解释：<br>1.&nbsp; String&nbsp;s1 =&nbsp;new&nbsp;String(\"he\")+new&nbsp;String(\"llo\"); 这样创建s1，会在堆中创建一个值为hello的对象<br>&nbsp; &nbsp; &nbsp;并且s1会指向它，但是在字符串池中不会创建，因为没有出现字面量“hello”<br>2.&nbsp; 之所以jdk1.7后的版本下这个例子创建的对象比jdk1.6的少一个，是因为jdk1.7后inter()方法在字符串<br>&nbsp; &nbsp; 池中找不到值为hello的String对象但是在堆中找到并且返回了堆中对象的引用，并且没有在字符串池中<br>&nbsp; &nbsp; 创建对象，而jdk1.6下，则会在这时在字符串中创建hello值的对象并返回引用。"}],"collapsed":true,"id":"928989b7d199","title":"8.&nbsp; 例题"}],"collapsed":true,"id":"173f8ed35ec1","title":"用构造器new&nbsp;String(String)创建对象<br>和直接赋值创建对象的区别："}],"collapsed":true,"id":"ed2f77660928","title":"String类"},{"parent":"791e0601cd54","children":[{"parent":"f9dad6bbdbe8","children":[{"parent":"47fd460e750a","children":[],"id":"93ad11e9f555","title":"1.&nbsp; 存在意义：<br>&nbsp; &nbsp; &nbsp;String类是保存字符串常量的。每次更新都需要重新开辟空间，效率较低，因<br>&nbsp; &nbsp; &nbsp;此java设计者还提供了StringBuilder和StringBuffer来增强String的功能，来<br>&nbsp; &nbsp; &nbsp;提高效率"},{"parent":"47fd460e750a","children":[],"id":"cb8aace9aad6","title":"2.&nbsp; StringBuffer是一个容器<br>&nbsp; &nbsp; &nbsp;StringBuffer代表可变的字符序列，可以对字符串内容进行增删。<br>&nbsp; &nbsp; &nbsp;很多方法与String相同，但StringBuffer是可变长度的。<br>&nbsp; &nbsp; &nbsp;并且StringBuffer是线程安全的"},{"parent":"47fd460e750a","children":[],"id":"e676539949dc","title":"3.&nbsp; StringBuffer中用于存储字符串的属性是父类AbstractStringBuilder<br>&nbsp; &nbsp; &nbsp;中的value数组，jdk8下value是字符数组，jdk9后是字节数组<br>&nbsp; &nbsp; &nbsp;这个value数组不是final的，意味着value的地址和内容都可以改变，<br>&nbsp; &nbsp; &nbsp;并且StringBuffer提供了修改value属性的方法，所以说StringBuffer<br>&nbsp; &nbsp; &nbsp;内容可修改并且是可变长度的（value地址可以修改，指向新长度的数组）"},{"parent":"47fd460e750a","children":[],"id":"3fe23255f882","title":"4.&nbsp; StringBuffer构造方法：<br>&nbsp; &nbsp; &nbsp;StringBuffer()<br>&nbsp; &nbsp; &nbsp;StringBuffer(CharSequence&nbsp;seq)<br>&nbsp; &nbsp; &nbsp;StringBuffer(int&nbsp;capacity)&nbsp;//capacity&nbsp;[容量]<br>&nbsp; &nbsp; &nbsp;StringBuffer(String&nbsp;str)"}],"collapsed":true,"id":"47fd460e750a","title":"StringBuffer结构剖析"},{"parent":"f9dad6bbdbe8","children":[{"parent":"f71417c1a76e","children":[],"id":"58395c459822","title":"1.&nbsp; 增：<br>&nbsp; &nbsp; &nbsp;StringBuffer&nbsp;append():将指定数据作为参数添加到已有数据结尾处。<br>&nbsp; &nbsp; &nbsp;StringBuffer&nbsp;insert(index,数据):可以将数据插入到指定的index位置。<br>2.&nbsp; 删：<br>&nbsp; &nbsp; &nbsp;StringBuffer&nbsp;delete(start,end);删除缓冲区中的数据，包含start，不包含end<br>&nbsp; &nbsp; &nbsp;StringBuffer&nbsp;deteleCharAt（index）：删除指定位置的字符。<br>3.&nbsp; 改：<br>&nbsp; &nbsp; &nbsp;StringBuffer&nbsp;replace(start，end，string)<br>&nbsp; &nbsp; &nbsp;void&nbsp;setCharAt（int&nbsp;index，char&nbsp;ch）<br>4.&nbsp; 查：<br>&nbsp; &nbsp; &nbsp;char&nbsp;charAt(int&nbsp;index)<br>&nbsp; &nbsp; &nbsp;int&nbsp;indexOf(String&nbsp;str)<br>&nbsp; &nbsp; &nbsp;int&nbsp;lastIndexOf(String&nbsp;str)<br>&nbsp; &nbsp; &nbsp;int&nbsp;length()<br>&nbsp; &nbsp; &nbsp;String&nbsp;substring(int&nbsp;start,int&nbsp;end)<br>5.&nbsp; 反转<br>&nbsp; &nbsp; &nbsp;StringBuffer&nbsp;reverse();<br>"}],"collapsed":true,"id":"f71417c1a76e","title":"StringBuffer常用方法"}],"collapsed":true,"id":"f9dad6bbdbe8","title":"StringBuffer类"},{"parent":"791e0601cd54","children":[{"parent":"5e8afd2458b3","children":[{"parent":"89d6423a844e","children":[],"id":"0557155753c3","title":"1.&nbsp; 存在意义：<br>&nbsp; &nbsp; &nbsp;java设计者除了提供了StringBuffer来增强String的功能，<br>&nbsp; &nbsp; &nbsp;还设计了StringBuilder来使字符串的使用更加高效，<br>&nbsp; &nbsp; &nbsp;StringBuilder是效率最高的，但是它是线程不安全的"},{"parent":"89d6423a844e","children":[],"id":"d1780f440dab","title":"2.&nbsp; StringBuilder和StringBuffer非常类似，都继承了AbstractStringBuilder，<br>&nbsp; &nbsp; &nbsp;均代表可变的字符序列，用于存储字符串的也是父类的value数组"},{"parent":"89d6423a844e","children":[],"id":"f416a067d072","title":"3.&nbsp; StringBuilder和StringBuffer方法一样，但StringBuilder的方法没有<br>&nbsp; &nbsp; &nbsp;synchronized修饰，是线程不安全的"},{"parent":"89d6423a844e","children":[],"id":"e57a69cbf153","title":"4.&nbsp; StringBuilder构造方法：<br>&nbsp; &nbsp; &nbsp;StringBuilder()<br>&nbsp; &nbsp; &nbsp;StringBuilder(CharSequence&nbsp;seq)<br>&nbsp; &nbsp; &nbsp;StringBuilder(int&nbsp;capacity)//capacity&nbsp;[容量]<br>&nbsp; &nbsp; &nbsp;StringBuilder(String&nbsp;str)"}],"collapsed":true,"id":"89d6423a844e","title":"StringBuilder结构剖析"},{"parent":"5e8afd2458b3","children":[{"parent":"12ba1684b715","children":[],"id":"30a0ae542e7f","title":"和StringBuffer一样，参考StringBuffer"}],"collapsed":true,"id":"12ba1684b715","title":"StringBuilder常用方法"}],"collapsed":true,"id":"5e8afd2458b3","title":"StringBuilder类"},{"parent":"791e0601cd54","children":[{"parent":"bd1642e0f926","children":[{"parent":"4d93a337c03f","children":[],"id":"698c6e52b28d","title":"1.&nbsp; String：不可变字符序列，效率低，但是复用率高。"},{"parent":"4d93a337c03f","children":[],"id":"dc53bb72a370","title":"2.&nbsp; StringBuffer：可变字符序列、效率较高(增删)、线程安全"},{"parent":"4d93a337c03f","children":[],"id":"0df9b3812aa0","title":"3.&nbsp; StringBuilder：可变字符序列、效率最高、线程不安全"},{"parent":"4d93a337c03f","children":[],"id":"47b0764cb29c","title":"4.&nbsp; StringBuilder和StringBuffer非常类似，均代表可变的字符序列，<br>&nbsp; &nbsp; &nbsp;方法和方法的使用一样，但StringBuilder方法不是线程安全的"}],"collapsed":true,"id":"4d93a337c03f","title":"区别"},{"parent":"bd1642e0f926","children":[{"parent":"86ec865d063e","children":[],"id":"2aaba85ba50d","title":"1.&nbsp; 如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder"},{"parent":"86ec865d063e","children":[],"id":"8a6bb6b2605d","title":"2.&nbsp; 如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder"},{"parent":"86ec865d063e","children":[],"id":"579a668fedba","title":"3.&nbsp; 如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer"},{"parent":"86ec865d063e","children":[],"id":"94f511a49468","title":"4.&nbsp; 如果我们字符串很少修改，被多个对象引用，使用String,&nbsp;比如配置信息等"}],"collapsed":true,"id":"86ec865d063e","title":"应用场景"}],"collapsed":true,"id":"bd1642e0f926","title":"String、StringBuffer、StringBuilder的<br>区别和应用场景"}],"collapsed":true,"id":"791e0601cd54","title":"字符串相关类"},{"parent":"c552c0131d9d","children":[{"parent":"b867e34bcbad","children":[],"id":"b21b6a9a5bdb","title":"Math类：<br>包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。"},{"parent":"b867e34bcbad","children":[],"id":"756f5e87656c","title":"Arrays类：<br>包含了一系列静态方法，用于管理或操作数组(比如排序和搜索)：<br>1.&nbsp; toString(Array[]&nbsp;array)参数为数组<br>&nbsp; &nbsp; 将数组按照默认格式输出为字符串<br>2.&nbsp; sort(Array[]&nbsp;array,)<br>&nbsp; &nbsp; &nbsp;将数组进行升序排序<br>3.&nbsp; binarySearch(Array[]&nbsp;array, data&nbsp;key)<br>&nbsp; &nbsp; 使用二分法查找元素在数组中的索引位置，传入的数组必须是排好序的<br>4.&nbsp; copyOf（arr，length）&nbsp;<br>&nbsp; &nbsp; 将数组arr复制成一个长度为length的新数组，底层还是System.arraycopy<br>"},{"parent":"b867e34bcbad","children":[],"id":"7f793c026210","title":"System类：<br>1.&nbsp; exit：退出当前程序<br>2.&nbsp; arraycopy ：复制数组元素，比较适合底层调用，是Arrays.copyOf方法底层调用的方法<br>3.&nbsp; currentTimeMillens：返回当前时间距离1970-1-1的毫秒数<br>4.&nbsp; gc：运行垃圾回收机制System.gc();"},{"parent":"b867e34bcbad","children":[],"id":"6fdbafe23efa","title":"BigInteger类和BigDecimal类：<br>1.&nbsp; BigInteger适合保存比较大的整型<br>2.&nbsp; BigDecimal适合保存精度更高的浮点型(小数)<br>注意：这两个类对象不能直接和基本类型使用+-*/运算符进行运算，他们对象之间也不可以<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 这两个类中有加减乘除的方法，运算时对象直接调用即可"},{"parent":"b867e34bcbad","children":[],"id":"e29e4cf7e462","title":"第一代日期类：Date类<br>第二代日期类：Calendar类<br>第三代日期类：LocalDate(年月日)、LocalTime(时分秒)、LocalDateTime(年月日时分秒)"}],"collapsed":true,"id":"b867e34bcbad","title":"其他工具类"}],"collapsed":false,"id":"c552c0131d9d","title":"六、Java API"},{"parent":"root","lineStyle":{"lineColor":"#666","lineWidth":2},"children":[{"parent":"67135c4f1dc0","children":[{"parent":"2255de2ffbb6","children":[],"id":"5a8c04166857","title":"需要保存多个数据时使用数组，但是数组的使用不够方便，<br>数组使用必须初始化长度，长度一旦确定就不可修改，数组<br>不能存放类型不同的元素，对元素的增删改查操作麻烦。<br>于是有了集合，集合可以动态保存多个对象，通过调用方法<br>进行元素的增删改查，对数据的使用更加方便了"}],"collapsed":true,"id":"2255de2ffbb6","title":"为什么使用集合"},{"parent":"67135c4f1dc0","children":[{"parent":"76a91610b481","children":[{"parent":"a9ba65bbe418","image":{"w":560,"h":230,"url":"http://cdn.processon.com/617f580b1efad41d03f79c4d?e=1635739164&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Moqc0HQTzhC5M4mXjkMGRIorXOE="},"children":[],"id":"f60796c8716d","title":""}],"collapsed":true,"id":"a9ba65bbe418","title":"单列集合"},{"parent":"76a91610b481","children":[{"parent":"716faf3daf44","image":{"w":505,"h":237,"url":"http://cdn.processon.com/617f58770791295c857b88f1?e=1635739271&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Aj_9KaO2AC_2qPpOVVr9i-rK094="},"children":[],"id":"1c9e9dc88b10","title":""}],"collapsed":true,"id":"716faf3daf44","title":"双列集合"},{"parent":"76a91610b481","children":[{"parent":"f3afd7c8922e","image":{"w":504,"h":330,"url":"http://cdn.processon.com/618b898b1e0853689b04b6cb?e=1636538268&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:mHbSxGcnJkv0jQ_CEaDoYdpopF8="},"children":[],"id":"0ccc1b3d7380","title":""},{"parent":"f3afd7c8922e","image":{"w":410,"h":387,"url":"http://cdn.processon.com/618b89bb1efad41bf2be46a1?e=1636538318&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:aFgx2iSh8SzrpY3xQhzeTgE6zWA="},"children":[],"id":"f9ff9767c3d3","title":""}],"collapsed":true,"id":"f3afd7c8922e","title":"集合框架"},{"parent":"76a91610b481","children":[{"parent":"b9bf814f441c","image":{"w":685,"h":528,"url":"http://cdn.processon.com/618b8a1af346fb6e38953c26?e=1636538411&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:hrDmTkGXlCnpJHZq875kn3d-3xM="},"children":[],"id":"689967f65657","title":""}],"collapsed":true,"id":"b9bf814f441c","title":"集合特点"}],"collapsed":true,"id":"76a91610b481","title":"集合体系图"},{"parent":"67135c4f1dc0","children":[{"parent":"f8a2d529bad3","children":[{"parent":"3f995e6bca09","children":[],"id":"70bfc22f9c62","title":"1.&nbsp; Collection接口实现子类可以存放多个元素，每个元素可以是Object"},{"parent":"3f995e6bca09","children":[],"id":"15f3dbd29d9c","title":"2.&nbsp; 有些Collection的实现类，可以存放重复的元素，有些不可以"},{"parent":"3f995e6bca09","children":[],"id":"ff8d620229bd","title":"3.&nbsp; 有些Collection的实现类，存放元素是有序的（List）,有些是无序的（Set）"},{"parent":"3f995e6bca09","children":[],"id":"8b5c665b06b8","title":"4.&nbsp;&nbsp;Collection接口没有直接的实现子类，都是通过子接口List和Set来实现的"}],"collapsed":true,"id":"3f995e6bca09","title":"Collection接口介绍"},{"parent":"f8a2d529bad3","children":[{"parent":"9ed7ed1eb1f3","children":[{"parent":"5c8b0eac617d","children":[],"id":"9d094ce02439","title":"所有的Collection实现子类都可以通过迭代器进行元素遍历，解释如下：<br><br>1.&nbsp; Collection接口继承了Iterable（可迭代的）接口，Iterable接口里只有一个需要实现的抽象方法：iterator()<br>&nbsp; &nbsp; &nbsp;iterator()方法返回的是一个Iterator接口实现类，Iterator接口中有两个用于迭代元素的方法。<br><br>2.&nbsp; 这也就意味着所有的Collection实现子类都需要实现iterator()方法，而实现该方法需要写一个Iterator接口的<br>&nbsp; &nbsp; &nbsp;实现类，这样Collection实现子类调用iterator()方法时可获得一个Iterator接口实现类对象，也就是迭代器，<br>&nbsp; &nbsp; 使用这个迭代器的方法即可遍历该集合的元素"}],"collapsed":true,"id":"5c8b0eac617d","title":"介绍"},{"parent":"9ed7ed1eb1f3","children":[{"parent":"2724bd473978","children":[],"id":"36ef0723618d","title":"1.&nbsp; hasNext()；方法：判断集合中是否还有元素，有则返回true没有返回false"},{"parent":"2724bd473978","children":[],"id":"ae9f3fce71bb","title":"2.&nbsp; next()：方法：返回当前元素，并将指针向下移动"},{"parent":"2724bd473978","children":[],"id":"962a679bbd30","title":"3.&nbsp; remove()；方法去掉集合中的当前元素"},{"parent":"2724bd473978","children":[],"id":"ca7a12dcf60e","title":"4.&nbsp; 规范使用，先hasNext()判断，再进行遍历：<br>&nbsp; &nbsp; &nbsp;while&nbsp;(iterator.hasNext()){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(iterator.next());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}"},{"parent":"2724bd473978","children":[],"id":"29e6cff49c8f","title":"解释（详细解释看源码）：<br>在Iterator实现类中：&nbsp;<br>&nbsp; &nbsp; &nbsp;有两个指针：cursor（初值为0）；lastRet（初值为-1）<br>&nbsp; &nbsp; &nbsp;1.&nbsp; 当调用hasNext()方法时，会判断cursor和集合大小（包含元素个数）是否相等<br>&nbsp; &nbsp; &nbsp;2.&nbsp; 当调用next()方法时，cursor会向下移动一格，lastRet也会向下移动一格，然后<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 返回的是集合的元素：elementData[lastRet]；注意！lastRet才是元素的下标！<br>&nbsp; &nbsp; &nbsp;3.&nbsp; 当调用remove()方法时，去掉元素的下标也是lastRet！<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如：ArrayList.this.remove(lastRet);"}],"collapsed":true,"id":"2724bd473978","title":"迭代器使用"},{"parent":"9ed7ed1eb1f3","children":[{"parent":"be246496afa6","children":[],"id":"f95d43466c1a","title":"1.&nbsp; 使用next()方法时应先调用hasNext()方法判断，否则遍历到最后一个元素还继续next()时<br>&nbsp; &nbsp; &nbsp;会直接抛出NoSuchElementException异常"},{"parent":"be246496afa6","children":[],"id":"0bc380a60e02","title":"2.&nbsp; 不能一上来就使用remove()方法，此时lastRet指针为-1，<br>&nbsp; &nbsp; &nbsp;会报IllegalStateException非法状态异常"},{"parent":"be246496afa6","children":[],"id":"766af3f1a1a0","title":"3.&nbsp; 当遍历结束后，若想重新遍历，需要重置迭代器：iterator = list.iterator();"},{"parent":"be246496afa6","children":[],"id":"375145af3641","title":"4.&nbsp; Collection子类集合对Iterator接口的实现，是以成员内部类的形式实现的，作为集合的一个属性，<br>&nbsp; &nbsp; 因此Iterator接口实现类可以直接调用集合类中的所有成员，所以iterator对象不存储数据，直接调用<br>&nbsp; &nbsp; 集合元素进行迭代操作"}],"collapsed":true,"id":"be246496afa6","title":"使用细节"},{"parent":"9ed7ed1eb1f3","children":[{"parent":"fe9afdedba5f","children":[],"id":"3c73b46fca4d","title":"for(元素类型 元素名 ：集合名或数组名){<br>&nbsp; &nbsp; //访问元素<br>}"},{"parent":"fe9afdedba5f","children":[],"id":"481643b47e72","title":"集合的增强for循环：底层实际上是使用迭代器"}],"collapsed":true,"id":"fe9afdedba5f","title":"增强for循环"}],"collapsed":true,"id":"9ed7ed1eb1f3","title":"迭代器"},{"parent":"f8a2d529bad3","children":[{"parent":"f4e8633becc8","children":[{"parent":"de9d70ef5e08","children":[{"parent":"ac655d36ec00","children":[],"id":"53dd18b59fb1","title":"1.&nbsp; List&nbsp;接口是Collection&nbsp;接口的子接口"},{"parent":"ac655d36ec00","children":[],"id":"fe2792852c52","title":"2.&nbsp; &nbsp;List集合类中元素有序(即添加顺序和取出顺序一致)、且可重复"},{"parent":"ac655d36ec00","children":[],"id":"8c79abc885b7","title":"3.&nbsp; List集合中的每个元素都有其对应的顺序索引，即支持索引<br>&nbsp; &nbsp; &nbsp; （&nbsp; 例如：可以 .get(index) 获取元素 ）"}],"collapsed":true,"id":"ac655d36ec00","title":"List接口介绍"},{"parent":"de9d70ef5e08","children":[{"parent":"ccfdc72f4836","children":[],"id":"294cec115527","title":"List&nbsp;集合里添加了一些根据索引来操作集合元素的方法：<br>1.&nbsp; void&nbsp;add(int&nbsp;index,&nbsp;Object&nbsp;ele)：在index位置插入ele元素<br>2.&nbsp; boolean&nbsp;addAll(int&nbsp;index,Collection&nbsp;eles)：从index位置开始将eles中的所有元素添加进来<br>3.&nbsp; Object&nbsp;get(int&nbsp;index)：获取指定index位置的元素<br>4.&nbsp; int&nbsp;indexOf(Object&nbsp;obj)：返回obj在集合中首次出现的位置<br>5.&nbsp; int&nbsp;lastlndexOf(Object&nbsp;obj)：返回obj在当前集合中末次出现的位置<br>6.&nbsp; Object&nbsp;remove(int&nbsp;index)：移除指定index位置的元素，并返回此元素<br>7.&nbsp; Object&nbsp;set(int&nbsp;index,&nbsp;Object&nbsp;ele)：设置指定index位置的元素为ele&nbsp;,相当于是替换<br>8.&nbsp; List&nbsp;subList(int&nbsp;fromIndex,&nbsp;int&nbsp;tolndex)：返回从fromIndex到tolndex位置的子集合<br>"}],"collapsed":true,"id":"ccfdc72f4836","title":"List接口常用方法"},{"parent":"de9d70ef5e08","children":[{"parent":"a3d68474cf4a","children":[{"parent":"de6103739774","children":[{"parent":"8d370a44268e","children":[],"id":"135b081c4a01","title":"ArrayList集合底层实际上是一个Object数组，ArrayList将这个数组封装起来，用于存放数据。<br>所以ArrayList集合存放的内容是一个一个的对象；因为ArrayList集合的底层数据容器是数组，<br>因此ArrayList实际上是列表型的容器，数据结构是线性列表"}],"collapsed":true,"id":"8d370a44268e","title":"ArrayList介绍"},{"parent":"de6103739774","children":[{"parent":"4e32fca42127","children":[],"id":"0be9e996ec19","title":"1.&nbsp; ArrayList可以加入null，并且多个<br>2.&nbsp; ArrayList底层实际是由数组来实现数据存储的，数据结构相当于列表<br>3.&nbsp; ArrayList基本等同于Vector，除了ArrayList是线程不安全(执行效率高)看源码.<br>&nbsp; &nbsp; &nbsp;在多线程情况下，不建议使用ArrayList<br>4.&nbsp; ArrayList和Vector的直接父类都是AbstractList<br>"}],"collapsed":true,"id":"4e32fca42127","title":"ArrayList注意事项"},{"parent":"de6103739774","children":[{"parent":"91a5a307df5f","children":[],"id":"985f9b9602b3","title":"1.&nbsp; ArrayList中维护了一个Object类型的数组elementData"},{"parent":"91a5a307df5f","children":[],"id":"7475f862a4a4","title":"2.&nbsp; 当创建ArrayList对象时，如果使用的是无参构造器，初始elementData容量为0，<br>&nbsp; &nbsp; &nbsp;第1次添加，则扩容elementData为10，如需要再次扩容，则扩容elementData为1.5倍。"},{"parent":"91a5a307df5f","children":[],"id":"1481a2f436b9","title":"3.&nbsp; 如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容,<br>&nbsp; &nbsp; &nbsp;则直接扩容elementData为1.5倍。<br>"}],"collapsed":true,"id":"91a5a307df5f","title":"ArrayList扩容机制"},{"parent":"de6103739774","children":[{"parent":"0d87e14bb506","children":[],"id":"632cc4ed6f5d","title":"扩容机制调用顺序：<br>第一步： 传入最小需求容量 minCapacity = size+1 当前元素个数加一 ，调用：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ensureCapacityInternal(int&nbsp;minCapacity) 确保内部容量：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ensureExplicitCapacity(calculateCapacity(elementData,&nbsp;minCapacity));<br><br>第二步： calculateCapacity(elementData,&nbsp;minCapacity) 计算所需最小容量<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;判断是不是无参构造器构造的0容量elementData，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果是，返回默认扩容量：10&nbsp; &nbsp; &nbsp; <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果不是，返回所需最小容量&nbsp;minCapacity<br><br>第三步：&nbsp; ensureExplicitCapacity(int&nbsp;minCapacity) 真正确保内部容量：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//判断当前数组的容量是否满足最小的容量需求<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if&nbsp;(minCapacity&nbsp;-&nbsp;elementData.length&nbsp;&gt;&nbsp;0)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//如果不满足，则进行扩容<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grow(minCapacity);<br><br>第四步：&nbsp; 若需要扩容，调用grow(minCapacity) 进行扩容，该方法看源码笔记<br><br>"}],"collapsed":true,"id":"0d87e14bb506","title":"ArrayList底层解释<br>（具体看源码笔记）"}],"collapsed":true,"id":"de6103739774","title":"ArrayList"},{"parent":"a3d68474cf4a","children":[{"parent":"d98837978cc0","children":[{"parent":"80ab3ccd8021","children":[],"id":"634504d17c5c","title":"Vector集合底层实际上是一个Object数组，和ArrayList一样将这个数组封装其来，用于存放数据<br>所以Vector集合存放的内容是一个一个的对象；因为Vector集合的底层数据容器是数组，<br>因此和ArrayList一样实际上是列表型的容器，数据结构是线性列表"}],"collapsed":true,"id":"80ab3ccd8021","title":"Vector介绍"},{"parent":"d98837978cc0","children":[{"parent":"eec488419ab7","children":[],"id":"d612a90106f2","title":"1.&nbsp; Vector底层也是一个对象数组，数据结构相当于列表，可以加入null，并且多个<br>2.&nbsp; Vector是线程同步的,即线程安全,&nbsp;Vector类的操作方法带有synchronized<br>3.&nbsp;&nbsp;在开发中,需要线程同步安全时,，考虑使用Vector，但效率较低<br>4.&nbsp; ArrayList和Vector的直接父类都是AbstractList<br>"}],"collapsed":true,"id":"eec488419ab7","title":"Vector注意事项"},{"parent":"d98837978cc0","children":[{"parent":"08259966507d","children":[],"id":"2d57645adb15","title":"0.&nbsp; Vector中有一个控制扩容增量的属性：capacityIncrement<br>&nbsp; &nbsp; &nbsp;若其大于0，则每次扩容，这个值就是增加的扩容量<br>&nbsp; &nbsp; &nbsp;若小于或等于零，则每次需要增长时，容量都会增加一倍"},{"parent":"08259966507d","children":[],"id":"74dd55ecf0ee","title":"1.&nbsp; 调用指定初始容量和自动增量的构造：<br>&nbsp; &nbsp; &nbsp;若传入的自动增量大于0，则每次扩容，容量扩为原容量加上这个增量<br>&nbsp; &nbsp; &nbsp;若传入自动增量小于等于0，每次扩容成两倍"},{"parent":"08259966507d","children":[],"id":"bcce4a326167","title":"2.&nbsp; 调用指定初始容量的构造：<br>&nbsp; &nbsp; &nbsp;该构造会调用指定初始容量和自动增量的构造，<br>&nbsp; &nbsp; &nbsp;并传入自动增量参数为0；默认扩容时扩成两倍"},{"parent":"08259966507d","children":[],"id":"a431679012d1","title":"3.&nbsp; 调用无参构造：<br>&nbsp; &nbsp; &nbsp;该构造会调用指定初始容量的构造，并传入初始容量10，<br>&nbsp; &nbsp; &nbsp;默认构造一个初始容量为10的Vector，扩容时默认扩成两倍"}],"collapsed":true,"id":"08259966507d","title":"Vector扩容机制"},{"parent":"d98837978cc0","children":[{"parent":"81398fa2c0a8","children":[],"id":"2b986f65d9e5","title":"扩容机制调用顺序：<br>第一步：传入最小需求容量&nbsp;minCapacity&nbsp;=&nbsp;size+1&nbsp;当前元素个数加一&nbsp;，调用：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ensureCapacityHelper(int&nbsp;minCapacity)，传入所需最小容量：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //判断当前数组的容量是否满足最小的容量需求<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if&nbsp;(minCapacity&nbsp;-&nbsp;elementData.length&nbsp;&gt;&nbsp;0)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //如果不满足，则进行扩容<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grow(minCapacity);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>第二步：若需要扩容，则调用grow(minCapacity);进行扩容，该方法看源码笔记"}],"collapsed":true,"id":"81398fa2c0a8","title":"Vector底层解释<br>（具体看源码笔记）"}],"collapsed":true,"id":"d98837978cc0","title":"Vector"},{"parent":"a3d68474cf4a","children":[{"parent":"7a1383d55210","children":[{"parent":"47197b888371","children":[],"id":"ddc1da2762b2","title":"LinkedList集合底层实际上是一个双向链表，LinkedList将集合的元素保存在双向链表的节点中，<br>也就是说，底层双向链表节点的内容item就是保存的集合元素；在LinkedList中，链表节点是一<br>个静态内部类，LinkedList集合每加入一个元素，底层就会创建一个Node节点对象，然后把元素<br>保存到节点对象属性item中，最后把这个节点插入到双向链表里"}],"collapsed":false,"id":"47197b888371","title":"LinkedList介绍"},{"parent":"7a1383d55210","children":[{"parent":"6c1747f3adb4","children":[],"id":"58566a95c1fd","title":"1.&nbsp;&nbsp;LinkedList可以加入null，并且多个<br>2.&nbsp;&nbsp;LinkedList底层实际是通过节点存储元素，再把节点连接起来一起管理的，数据结构是双向链表<br>3.&nbsp; LinkedList实际上是链表，因此不存在扩容机制<br>4.&nbsp; LinkedList是线程不安全的<br>5.&nbsp;&nbsp;LinkedList直接父类AbstractSequentialList<br>"}],"collapsed":true,"id":"6c1747f3adb4","title":"LinkedList注意事项"},{"parent":"7a1383d55210","children":[{"parent":"d80ad9a59321","children":[],"id":"8fc0ffec7982","title":"1.&nbsp; LinkedList中包含了静态内部类：Node节点<br>2.&nbsp; Node节点的属性item，用于保存加入LinkedList集合的元素，是封装数据的地方<br>3.&nbsp; LinkedList通过创建Node节点对象来保存元素，并且将他们连接起来形成链表<br>4.&nbsp; Node节点包含prev属性和next属性（两者都是Node类型），所以LinkedList内部<br>&nbsp; &nbsp; &nbsp;形成的链表是双向链表<br>5.&nbsp;&nbsp;LinkedList对外提供的操作集合元素的方法，底层上实际是调用操作双向链表节点的方法"}],"collapsed":true,"id":"d80ad9a59321","title":"LinkedList底层解释"}],"collapsed":false,"id":"7a1383d55210","title":"LinkedList"},{"parent":"a3d68474cf4a","children":[{"parent":"04cca483c688","children":[],"id":"1a62fa2316f6","title":"ArrayList和LinkedList的区别：<br>1.&nbsp; ArrayList是可变数组，增删效率较低需要扩容，改查效率较高<br>2.&nbsp; LinkedList是双向链表，增删效率较高不需要扩容机制，改查效率较低<br>3.&nbsp; ArrayList和LinkedList都是线程不安全的，需要在单线程环境下使用，<br>&nbsp; &nbsp; &nbsp;或在外部实现同步"},{"parent":"04cca483c688","children":[],"id":"4fc9019f3f0a","title":"List集合的选择：<br>1.&nbsp; 如果我们改查的操作多，选择ArrayList<br>2.&nbsp; 如果我们增删的操作多，选择LinkedList<br>3.&nbsp; 一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList<br>4.&nbsp; 在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，<br>&nbsp; &nbsp; &nbsp;另外一个模块是LinkedList，也就是说,要根据业务来进行选择"}],"collapsed":true,"id":"04cca483c688","title":"List集合选择"}],"collapsed":true,"id":"a3d68474cf4a","title":"List接口实现类"}],"collapsed":true,"id":"de9d70ef5e08","title":"List接口"},{"parent":"f4e8633becc8","children":[{"parent":"3bc3defdc829","children":[{"parent":"bd399a0faac4","children":[],"id":"88d56a6a82f7","title":"1.&nbsp; Set 接口是Collection&nbsp;接口的子接口"},{"parent":"bd399a0faac4","children":[],"id":"bb725dacf29f","title":"2.&nbsp; Set集合类中元素是无序的(元素随机无序存储)<br>&nbsp; &nbsp; &nbsp;因为Set集合类底层都是Map的实现类<br>&nbsp; &nbsp; &nbsp;取出顺序和添加顺序不一致，是随机的<br>&nbsp; &nbsp; &nbsp;但是取出的顺序是固定的，确定了取出顺序后就不再改变了<br>&nbsp; &nbsp; <br>&nbsp; &nbsp; 特殊的是：<br>&nbsp; &nbsp; 1.&nbsp; LinkedHashSet可以保证添加顺序和取出顺序一致，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;即能够保持顺序，但其本质也是无序的<br>&nbsp; &nbsp; 2.&nbsp; TreeSet可以实现排序存放，需要构造时传入比较器"},{"parent":"bd399a0faac4","children":[],"id":"0a6f4c4f2c75","title":"3.&nbsp; Set集合元素不可重复，所以最多只能有一个null"},{"parent":"bd399a0faac4","children":[],"id":"893c982dda30","title":"4.&nbsp; Set集合不支持索引"},{"parent":"bd399a0faac4","children":[],"id":"86c83a9b214e","title":"5.&nbsp; Set集合是单列集合，但是底层元素实际上还是以键值对形式存在的，<br>&nbsp; &nbsp; 只是元素数据存放在键值对中的键Key中，键值Value用一个常量占位替代"}],"collapsed":true,"id":"bd399a0faac4","title":"Set接口介绍"},{"parent":"3bc3defdc829","children":[{"parent":"99afadd7551e","children":[],"id":"dd2eef7e6d2b","title":"Set集合的常用方法，Set集合类不支持索引：<br>1.&nbsp; boolean&nbsp;add(E&nbsp;e) ：将指定的元素添加到该集合中<br>2.&nbsp; boolean&nbsp;addAll(Collection&lt;?&nbsp;extends&nbsp;E&gt;&nbsp;c) ：将指定集合中的所有元素添加到该集合中<br>3.&nbsp; boolean&nbsp;contains(Object&nbsp;o) ：判断是否包含指定的元素<br>4.&nbsp; boolean&nbsp;containsAll(Collection&lt;?&gt;&nbsp;c) ：判断是否包含指定集合的所有元素<br>5.&nbsp; int&nbsp;hashCode()：返回此组的哈希代码值<br>6.&nbsp; boolean&nbsp;remove(Object&nbsp;o)：从该集合中移除指定的元素<br>7.&nbsp; boolean&nbsp;removeAll(Collection&lt;?&gt;&nbsp;c) ：从这个集合中移除包含在指定集合中的所有元素<br>8.&nbsp; void&nbsp;clear() ：从这个集合中移除所有的元素（可选操作）"}],"collapsed":true,"id":"99afadd7551e","title":"Set接口常用方法"},{"parent":"3bc3defdc829","children":[{"parent":"3297c3940938","children":[{"parent":"bb3dc1ad8963","children":[{"parent":"d46dd236e378","children":[],"id":"4bc5449421a7","title":"1.&nbsp; 和List集合不同，HashSet是无序的单列集合<br><br>2.&nbsp; HashSet的底层实际上是HashMap；<br>&nbsp; &nbsp; &nbsp;HashSet维护了一个HashMap对象map来存放元素，因此HashSet是线程不安全的<br><br>3.&nbsp; HashMap底层是：数组+链表(可能树化成红黑树)+红黑树（由链表转变）的数据结构<br>&nbsp; &nbsp; &nbsp;（Hash的意思是：散列表，散列表也称哈希表）<br><br>4.&nbsp;&nbsp;HashSet顾名思义也是用到了这样的Hash结构，这样的结构元素是无序存放的<br><br>5.&nbsp; 注意的是，HashMap中的Node节点和TreeNode节点存储数据既有键Key，又有键值value，<br>&nbsp; &nbsp; &nbsp;是以键值对的形式存储的，因此知道HashMap是双列集合；<br>&nbsp; &nbsp; &nbsp;而HashSet是单列集合，既为了通过HashMap构成散列表结构，实现无序，<br>&nbsp; &nbsp; &nbsp;又为了符合单列，HashSet底层构建HashMap对象来存储元素时：<br>&nbsp; &nbsp; &nbsp;会默认将HashMap对象的键Key作为存放HashSet元素的地方，<br>&nbsp; &nbsp; &nbsp;而将HashMap对象的键值value用一个所有HashSet元素共享的Object对象来赋值，只是起到一个占位的作用<br>&nbsp; &nbsp; &nbsp;这样HashSet就能够使用到数组+链表(会树化)的数据结构来存储数据，而不用单独重新完成这个数据结构了<br>"}],"collapsed":true,"id":"d46dd236e378","title":"HashSet介绍"},{"parent":"bb3dc1ad8963","children":[{"parent":"aaedc5bdd485","children":[],"id":"7ef7dfe89eb0","title":"1.&nbsp; HashSet底层是HashMap，因此HashSet的扩容机制实际上是HashMap的扩容机制："},{"parent":"aaedc5bdd485","children":[],"id":"d7b35994ae39","title":"2.&nbsp; HashMap表头扩容机制：<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;2.1&nbsp; HashMap设置了一个表头扩容临界值threshold，当HashMap元素个数size超过它时<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 会对表头数组扩容2倍；<br><br>&nbsp; &nbsp; &nbsp;2.2&nbsp; 扩容临界值 = 当前表头数组容量 * 负载因子<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;2.3&nbsp; 负载因子loadFactor，不用指定负载因子构造器构造，默认是0.75<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;2.4&nbsp; 使用无参构造，默认负载因子0.75，初始表头为null<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 调用put()方法添加第一个元素，进行第一次扩容时，默认表头数组容量为16，因此<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 扩容临界值为12；HashMap元素超过12个时，扩容至32，临界值变成24，以此类推&nbsp;<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;2.5&nbsp; 调用有参构造传入指定容量时，由于表头数组的容量必须是2的次幂，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 需要通过tableSizeFor()计算出&gt;=指定容量的最小2次幂数，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 将这个值赋给扩容阈值，此时扩容阈值就代表了表头进行初始化的容量大小<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在加入第一个元素调用put()方法时，进行第一次扩容（初始化）的时候，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 会将表头数组容量扩容为扩容阈值的大小，例如：传入5---&gt;初始化为8，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后将扩容阈值更新为这个数与负载因子的乘积<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;2.6&nbsp; 当某条链表的元素个数超过TREEIFY_THRESHOLD(默认是8)，table大小没到<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MIN&nbsp;TREEIFY&nbsp;CAPACITY(默认64)，会对table扩容2倍<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;2.7&nbsp; HashMap扩容后可能会改变原来元素的索引位置，也就是可能移动链表或树"},{"parent":"aaedc5bdd485","children":[],"id":"67d92a1d73c5","title":"3.&nbsp; HashMap链表树化机制（红黑树）：<br>&nbsp; &nbsp; &nbsp;在Java8中,如果一条链表的元素个数超过 TREEIFY_THRESHOLD(默认是8)，<br>&nbsp; &nbsp; &nbsp;并且table的大小&gt;=MIN&nbsp;TREEIFY&nbsp;CAPACITY(默认64)，就会进行树化(红黑树)<br>&nbsp; &nbsp; &nbsp;否则采用扩容机制对表头扩容2倍"}],"collapsed":true,"id":"aaedc5bdd485","title":"HashSet扩容和树化机制"},{"parent":"bb3dc1ad8963","children":[{"parent":"1f20a7f3b839","children":[],"id":"9a372027392c","title":"1.&nbsp; 调用HashSet的add()方法对元素进行添加，实际上就是调用底层的HashMap对象map的put()方法添加元素<br><br>2.&nbsp; 只不过调用put()时，将HashSet元素对象作为传入的key参数，value参数用共享的Object对象PRESENT传入<br><br>3.&nbsp; 因此具体添加机制直接查看HashMap的put()方法即可"}],"collapsed":true,"id":"1f20a7f3b839","title":"HashSet元素添加机制<br>&nbsp; &nbsp; &nbsp; （add方法）"}],"collapsed":true,"id":"bb3dc1ad8963","title":"HashSet"},{"parent":"3297c3940938","children":[{"parent":"a9c9aec816c6","children":[{"parent":"c590e5de4bb7","children":[],"id":"a40985913219","title":"1.&nbsp;&nbsp;LinkedHashSet是HashSet的子类，因此是线程不安全的<br><br>2.&nbsp;&nbsp;LinkedHashSet的底层实际上是LinkedHashMap，LinkedHashMap是HashMap的子类<br><br>3.&nbsp;&nbsp;LinkedHashSet继承了HashSet维护的用于存放数据的HashMap对象map，而LinkedHashSet需要将<br>&nbsp; &nbsp; &nbsp;存放数据的底层容器设计成LinkedHashMap，所以LinkedHashSet的所有构造器进行构造时，<br>&nbsp; &nbsp; &nbsp;会调用父类HashSet的构造：HashSet(int&nbsp;initialCapacity,&nbsp;float&nbsp;loadFactor,&nbsp;boolean&nbsp;dummy)<br>&nbsp; &nbsp; &nbsp;该构造将HashSet维护的这个map指向新创建的LinkedHashMap对象（向上转型），这样LinkedHashSet底层<br>&nbsp; &nbsp; &nbsp;维护的map的实际（运行）类型就是LinkedHashMap类型了，真正存放LinkedHashSet元素的地方<br><br>4.&nbsp;&nbsp;LinkedHashMap中存放元素的位置是LinkedHashMap的一个静态内部类对象Entry节点，<br>&nbsp; &nbsp; &nbsp;Entry节点是HashMap中Node节点的子节点，拥有Node节点的所有属性外，Entry节点还设置了两个指针：<br>&nbsp; &nbsp; &nbsp;前指针before和后指针after，用于指向加入该LinkedHashMap集合的上一个元素和下一个元素，<br>&nbsp; &nbsp; &nbsp;也就是说当一个元素加入到集合中时，它的before会指向上一个加入集合的元素，不管这个元素存放在哪里，<br>&nbsp; &nbsp; &nbsp;而上一个加入集合的元素的after会指向当前加入集合的这个元素，形成了一个双向链表，<br>&nbsp; &nbsp; &nbsp;从而保存了元素加入LinkedHashMap集合的顺序，这样在遍历的时候可以根据这个引导按照加入顺序取出元素，<br>&nbsp; &nbsp; &nbsp;使得LinkedHashMap的元素看起来是“有序的”，<br>&nbsp; &nbsp; &nbsp;但实际上仍是无序的，只不过通过一个双向链表记录了元素的加入顺序，也不支持索引<br><br>5.&nbsp; 因为LinkedHashSet的底层是LinkedHashMap，所以其数据结构就是LinkedHashMap的数据结构<br><br>6.&nbsp; LinkedHashMap的数据结构：数组+链表（可能树化）+红黑树（由链表转化）+双向链表&nbsp;<br>&nbsp; &nbsp; &nbsp;LinkedHashMap的数据结构和HashMap基本一致，都是hash结构，表头后面的单链表会进行树化<br>&nbsp; &nbsp; &nbsp;唯一的区别仅仅是LinkedHashMap比HashMap多了一个维护元素加入次序的双向链表<br><br>"}],"collapsed":true,"id":"c590e5de4bb7","title":"LinkedHashSet介绍"},{"parent":"a9c9aec816c6","children":[{"parent":"f02ec017b4f3","children":[],"id":"66c52b6cdb90","title":"1.&nbsp; LinkedHashSet的底层是LinkedHashMap，<br>&nbsp; &nbsp; &nbsp;而LinkedHashMap的表头table，是从HashMap继承下来的，也就是说，<br>&nbsp; &nbsp; &nbsp;LinkedHashMap的表头数组就是Node[]数组，而挂载到表头上的元素，<br>&nbsp; &nbsp; &nbsp;是Node节点的子节点，Entry节点，所以这里相当于是一个多态数组<br><br>2.&nbsp; 所以LinkedHashSet的扩容机制和树化机制和HashSet是完全一致的"}],"collapsed":true,"id":"f02ec017b4f3","title":"LinkedHashSet扩容和树化机制"},{"parent":"a9c9aec816c6","children":[{"parent":"bb1cb8016e24","children":[],"id":"97769e596376","title":"1.&nbsp; 添加一个元素时，LinkedHashSet底层实际调用的是HashMap的put方法<br>&nbsp; &nbsp; &nbsp;具体添加机制在LinkedHashMap中查看<br>&nbsp; &nbsp; &nbsp;简单解释：<br>&nbsp; &nbsp; &nbsp;添加一个元素时，LinkedHashSet调用的是HashSet的add()方法，因为LinkedHashSet没有重写add()方法，<br>&nbsp; &nbsp; &nbsp;又因为LinkedHashSet构造时会将HashSet维护的map指向LinkedHashMap对象，所以调用HashSet的add()方法时，<br>&nbsp; &nbsp; &nbsp;会执行动态绑定机制，执行的是LinkedHashMap的put方法，而LinkedHashMap没有重写put方法，<br>&nbsp; &nbsp; &nbsp;所以最后执行的还是HashMap的put方法<br><br>"},{"parent":"bb1cb8016e24","children":[],"id":"8c94a0271ccf","title":"2.&nbsp; 所以LinkedHashSet添加元素的原则和HashSet一样，<br>&nbsp; &nbsp; &nbsp;但是每加入一个元素，就会把该元素加入到双向链表中，<br>&nbsp; &nbsp; &nbsp;形成加入次序的维护"},{"parent":"bb1cb8016e24","children":[],"id":"41dcfaf54e1d","title":"3.&nbsp; 为了了解LinkedHashSet的方法调用，再啰嗦一下：<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;LinkedHashSet除了重写了父类HashSet的spliterator()方法外，没有重写任何HashSet的方法，<br>&nbsp; &nbsp; &nbsp;也没有写任何独特的方法，所以LinkedHashSet每次调用方法时，都是在调用父类HashSet的方法，<br>&nbsp; &nbsp; &nbsp;当调用父类HashSet的方法时，如果调用了map的方法，因为这个map是LinkedHashMap类型的，所以会<br>&nbsp; &nbsp; &nbsp;调用LinkedHashMap的方法（动态绑定），如果是LinkedHashMap重写了的方法，则调用重写后的方法<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;意义：<br>&nbsp; &nbsp; &nbsp;中间的过程包含了多态、动态绑定<br><br>"}],"collapsed":true,"id":"bb1cb8016e24","title":"LinkedHashSet元素添加机制<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; （add方法）"}],"collapsed":true,"id":"a9c9aec816c6","title":"LinkedHashSet"},{"parent":"3297c3940938","children":[],"id":"6c982e765907","title":"TreeSet"},{"parent":"3297c3940938","children":[{"parent":"1a9040fa9a66","children":[],"id":"be2f27701b7e","title":"HashSet和LinkedHashSet都是无序的，通常选择HashSet即可<br>当需要知道或记录元素添加顺序时，可以使用LinkedHashSet"}],"collapsed":true,"id":"1a9040fa9a66","title":"Set集合选择"}],"collapsed":true,"id":"3297c3940938","title":"Set接口实现类"}],"collapsed":true,"id":"3bc3defdc829","title":"Set接口"}],"collapsed":true,"id":"f4e8633becc8","title":"Collection子接口"}],"collapsed":true,"id":"f8a2d529bad3","title":"Collection接口"},{"parent":"67135c4f1dc0","children":[{"parent":"0c6ffa9edf75","children":[{"parent":"1dbc5590d0a7","children":[],"id":"244c83a94479","title":"1.&nbsp; Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value"},{"parent":"1dbc5590d0a7","children":[],"id":"e9c9da49b1e4","title":"2.&nbsp; Map中的key和value可以是任何引用类型的数据，会封装到静态内部类节点对象中"},{"parent":"1dbc5590d0a7","children":[],"id":"2cc1a795c78a","title":"3.&nbsp; Map的元素的键key是不能重复的，也就是一个Map集合中不能有重复键key的元素<br>&nbsp; &nbsp; 但是Map的元素的键值value是可以重复，也就是一个Map集合中可以有重复键值value的元素"},{"parent":"1dbc5590d0a7","children":[],"id":"179f1ae2e0a3","title":"4.&nbsp; HashMap&nbsp;的key&nbsp;可以为null,&nbsp;value&nbsp;也可以为null，key为null的元素只能有一个，value为null的元素可以多个<br>&nbsp; &nbsp; &nbsp;Hashtable 的key和value都不能为null"},{"parent":"1dbc5590d0a7","children":[],"id":"691a2480fed7","title":"5.&nbsp; 常用String类作为Map的&nbsp;key"},{"parent":"1dbc5590d0a7","children":[],"id":"932608e8decf","title":"6.&nbsp; key&nbsp;和&nbsp;value之间存在单向一对一关系，即通过指定的key&nbsp;总能找到对应的value"}],"collapsed":true,"id":"1dbc5590d0a7","title":"Map接口介绍"},{"parent":"0c6ffa9edf75","children":[{"parent":"ebc38d871e8b","children":[],"id":"d0cd60ee9373","title":"Map集合的常用方法，Map集合不支持索引：<br>1.&nbsp; put()：添加<br>2.&nbsp; remove()：根据键删除映射关系<br>3.&nbsp; get()：根据键获取值<br>4.&nbsp; size()：获取元素个数<br>5.&nbsp; isEmpty()：判断个数是否为0<br>6.&nbsp; clear()：清除<br>7.&nbsp; containsKey()：查找键是否存在<br>8.&nbsp; keySet() ：返回一个这个Map键key 的Set集合<br>9.&nbsp; values() ：返回一个这个Map键值value的Collection集合<br>10.&nbsp; &nbsp;entrySet()：返回一个这个Map键值对的Set集合<br>"}],"collapsed":true,"id":"ebc38d871e8b","title":"Map接口常用方法"},{"parent":"0c6ffa9edf75","children":[{"parent":"39d98f88ac73","children":[],"id":"f8e4f998057d","title":"由于Map接口没有实现Iterable（可迭代的）接口，而且Map集合是不支持索引的，所以Map集合对象不可以直接进行遍历，<br>为了方便程序员遍历Map集合，Map集合提供了三个方法，可以返回Map的元素视图：<br><br>1.&nbsp; keySet() ：返回一个这个Map键key 的Set集合<br>2.&nbsp; values() ：返回一个这个Map键值value的Collection集合<br>3.&nbsp; entrySet()：返回一个这个Map键值对的Set集合<br><br>这三个方法返回的Map视图集合，都实现了Iterable（可迭代的）接口，因此可以调用他们的迭代器进行遍历：<br>（关于这个元素视图的详细实现看源码笔记）"},{"parent":"39d98f88ac73","children":[],"id":"968a1911ee0c","title":"方法一、二：<br>1.&nbsp; 调用keySet()方法返回Map集合的键key的set集合，使用iterator()返回迭代器进行遍历<br>2.&nbsp;&nbsp;调用keySet()方法返回Map集合的键key的set集合，使用增强for循环进行遍历（底层实际还是调用迭代器）"},{"parent":"39d98f88ac73","children":[],"id":"7a02440f2172","title":"方法三、四：<br>1.&nbsp; 调用values()方法返回Map集合的键值value的Collection集合，使用iterator()返回迭代器进行遍历<br>2.&nbsp;&nbsp;调用values()方法返回Map集合的键值value的Collection集合，使用增强for循环进行遍历（底层实际还是调用迭代器）<br>"},{"parent":"39d98f88ac73","children":[],"id":"ef4755d4ff6a","title":"方法五、六：<br>1.&nbsp; 调用entrySet()方法返回Map键值对的Set集合，使用iterator()返回迭代器进行遍历<br>2.&nbsp;&nbsp;调用entrySet()方法返回Map键值对的Set集合，使用增强for循环进行遍历（底层实际还是调用迭代器）<br>另外：调用entrySet()方法返回Map键值对的Set集合：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;该Set集合元素可以调用 .getKey() 方法获得这个Map集合元素的键key<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;该Set集合元素可以调用&nbsp;.getValue() 方法获得这个Map集合元素的键值value"}],"collapsed":true,"id":"39d98f88ac73","title":"Map接口遍历方式"},{"parent":"0c6ffa9edf75","children":[{"parent":"a47de7413880","children":[{"parent":"3082cb195840","children":[],"id":"ce579574523b","title":"为什么需要哈希表：<br><br>在我们知道数组中某元素的下标值时，我们可以通过下标值的方式获取到数组中对应的元素，这种获取元素的速度是非常快的。<br>但是如果我们不知道某个元素的下标值，而只是知道该元素在数组中，这时我们想要获取该元素就只能对数组进行线性查找，<br>即从头开始遍历，这样的效率是非常低的，如果一个长度为10000的数组，我们需要的元素正好在第10000个，<br>那么我们就要对数组遍历10000次，显然这是不合理的。<br><br>所以，为了解决上述数组的不足之处，引入了哈希表的概念<br>"},{"parent":"3082cb195840","children":[],"id":"35675b192fa8","title":"什么是哈希表：<br><br>哈希表（Hash&nbsp;table，也叫散列表），存放的数据元素是 键值对 key-value 的形式的，<br>哈希表是根据关键码值key而直接进行访问的数据结构。<br>也就是说，它通过把关键码值key映射到表中一个索位置来访问记录，以加快查找的速度。<br>这个映射函数叫做散列函数。<br><br>这样当从哈希表中查找一个元素时，根据元素的key定位到元素所在哈希表中的索引位置<br>就可以查到元素，而不用从数组头往后遍历查找了。<br>"},{"parent":"3082cb195840","children":[],"id":"0889c0acdb49","title":"哈希表的优缺点：<br>优点：<br>1.&nbsp; 无论数据有多少，处理起来都特别的快<br>&nbsp; &nbsp; &nbsp;能够快速地进行&nbsp;插入修改元素&nbsp;、删除元素&nbsp;、查找元素&nbsp;等操作<br>2.&nbsp; 代码简单（其实只需要把哈希函数写好，之后的代码就很简单了）<br><br>缺点：<br>1.&nbsp; 哈希表中的数据是没有顺序的<br>2.&nbsp; 数据不允许重复<br>"},{"parent":"3082cb195840","children":[],"id":"228ff5ed5062","title":"哈希碰撞：<br><br>两个哈希表元素的键key通过哈希函数计算出的哈希表索引位置相同，也就是说他们应当放在哈希表中<br>的位置冲突了（哈希函数可能导致这样的结果），那么说这两个元素发生了哈希碰撞<br>如果说这两个元素其实不是重复的元素，但因为这样的偶然情况使得后一个元素无法加入哈希表中了，<br>这样是我们不希望的，所以应当想办法使后一个元素也加入到表中<br><br>"},{"parent":"3082cb195840","children":[],"id":"b3b579fde526","title":"拉链法解决哈希碰撞：<br>将索引位置相同但是又不重复的两个哈希表元素以链表的形式存储，<br>也就是说后一个元素与一个元素发生哈希碰撞时，添加到该元素的链表后面"}],"collapsed":true,"id":"3082cb195840","title":"哈希表与哈希碰撞"},{"parent":"a47de7413880","children":[{"parent":"420a24f3c639","children":[],"id":"cf0842db7901","title":"1.&nbsp; 如果重写了equals()方法的对象，是哈希结构集合的元素的键key，那么就一定要重写hashCode()方法。<br>&nbsp; &nbsp; &nbsp;否则很可能出现严重的逻辑错误（不是编译上的错误），这个严重的逻辑错误是：<br>&nbsp; &nbsp; &nbsp;很可能会向哈希结构的集合中添加了逻辑上“重复”的元素，而哈希结构的集合是不允许元素重复的"},{"parent":"420a24f3c639","children":[],"id":"367188a4e2ea","title":"2.&nbsp; 对第1点的解释：<br>&nbsp; &nbsp; 在Object类equals()方法的注释里说明了：<br>&nbsp; &nbsp; 每当重写此方法时，通常都需要重写hashCode()方法，<br>&nbsp; &nbsp; 以维护hashCode()方法的一般约定，即相等的对象必须具有相等的哈希码"},{"parent":"420a24f3c639","children":[],"id":"c035e6ec60cc","title":"3.&nbsp; 从哈希集合的角度具体解释：<br>&nbsp; &nbsp; 1.&nbsp; &nbsp;哈希集合获取元素的键key的hashCode值，通过哈希函数计算出元素在哈希表中的索引位置<br>&nbsp; &nbsp; 2.&nbsp; &nbsp;两个key的hashCode值不同的元素通过哈希函数计算后得出了相同的索引值，那么他们会因为存放空间<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 相同而发生碰撞<br>&nbsp; &nbsp; 3.&nbsp; 发生碰撞的两个元素，会通过调用他们key的equals()方法来确定两者是否是重复的元素，如果不重复，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;则以链表形式存储他们<br>&nbsp; &nbsp; 4.&nbsp; 关键就是第3点发生碰撞时的“重复”判断，这个“重复”在该元素的key没有重写equals()方法时的<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;判断逻辑是比较两个元素的key对象地址，判断他们到底是不是指向同一地址的同一个对象<br>&nbsp; &nbsp; 5.&nbsp; 而当设计者根据设计的逻辑重写了equals()方法，例如：比较对象的某些字段，相同表示重复<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;也就是说此时判断两个元素重复的逻辑不再是根据他们key的地址比较了，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;那么此时如果不重写hashCode()方法很可能出现严重的逻辑错误：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果new了两个key对象，他们的equals()判断是为false的，也就是说，逻辑上这两个元素是重复的，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;他们不能同时加入到一个哈希集合中；但此时没有重写hashCode()方法，这两个对象的hashCode值通过<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Object类默认的hashCode()方法得出，所以他们的hashCode值不一样。那么在加入哈希集合中的时，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;根据他们的hashCode值计算出了两个不同的索引值（不发生碰撞的情况下），那么这两个元素就都加入<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;到了一个哈希集合中。造成严重的逻辑错误：哈希集合中出现了逻辑上重复的元素&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;"},{"parent":"420a24f3c639","children":[],"id":"7eaebd5e328c","title":"4.&nbsp; 在保证逻辑上等价或重复的对象其hashCode值必须相同的原则下，<br>&nbsp; &nbsp; &nbsp;也应该尽可能的使不等价的对象其hashCode值不同，以减少哈希碰撞的发生，提高哈希容器的效率<br>&nbsp; &nbsp; &nbsp;举个例子：<br>&nbsp; &nbsp; &nbsp;在某类的hashCode()方法中，直接返回一个固定的值。这样写虽然一定保证了逻辑上等价的对象一定<br>&nbsp; &nbsp; &nbsp;拥有同样的hashCode值，但是不等价的对象其hashCode值也一样了，意味着所有的对象都会发生哈<br>&nbsp; &nbsp; &nbsp;希碰撞，严重影响哈希容器的效率"}],"collapsed":true,"id":"420a24f3c639","title":"哈希集合的重要重写原则"},{"parent":"a47de7413880","children":[{"parent":"b5a727138d17","children":[{"parent":"e8099d744b4b","children":[],"id":"500f31219a50","title":"1.&nbsp; 版本：HashMap是jdk1.2时出现的，Hashtable是jdk1.0出现的<br>2.&nbsp; 线程安全：HashMap是不安全的，Hashtable是安全的<br>3.&nbsp; 性能：HashMap效率更高，Hashtable效率相对较低<br>4.&nbsp; null值：HashMap的key和value都允许为null，Hashtable都不允许"}],"collapsed":true,"id":"e8099d744b4b","title":"宏观区别"},{"parent":"b5a727138d17","children":[{"parent":"5f79faf41ab1","children":[],"id":"7e635ee8e2eb","title":"1.&nbsp; HashMap对数量达到一定值的链表会进行树化处理，来提高效率，而Hashtable不会"},{"parent":"5f79faf41ab1","children":[],"id":"880e953298c4","title":"2.&nbsp; HashMap对计算元素在哈希表中的hash值时，有一个加工处理hash()方法；<br>&nbsp; &nbsp; &nbsp;Hashtable则没有，而是直接使用元素键key的hashCode值作为元素的hash值"},{"parent":"5f79faf41ab1","children":[],"id":"5c2183bfe0a7","title":"3.&nbsp; HashMap和Hashtable根据元素的hash值确定其索引的方法也不同"},{"parent":"5f79faf41ab1","children":[],"id":"8d5902859d72","title":"4.&nbsp; HashMap的table表的初始化工作（也就是表头为null或者0时的第一次扩容）<br>&nbsp; &nbsp; &nbsp;在put方法中调用扩容方法执行；而Hashtable则直接在构造器中直接初始化，<br>&nbsp; &nbsp; &nbsp;如果是null，则直接指定容量为11，如果是0，则直接指定为1"},{"parent":"5f79faf41ab1","children":[],"id":"9765fe804b73","title":"5.&nbsp;&nbsp;HashMap和Hashtable的扩容机制都设置了扩容因子和扩容阈值，但是有细节的不同：<br>&nbsp; &nbsp; &nbsp;（1） HashMap表头指定为null时，初始化容量为16，Hashtable为11；<br>&nbsp; &nbsp; &nbsp;（2） HashMap触发扩容将原容量扩为2倍，Hashtable将原容量扩为2倍加1；<br>&nbsp; &nbsp; &nbsp;（3） HashMap的某条链表超过默认值8，并且表头容量没到达64时，会触发扩容，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Hashtable则没有这个机制；<br>&nbsp; &nbsp; &nbsp;（4） 相同的是两者的默认扩容因子都为0.75"},{"parent":"5f79faf41ab1","children":[],"id":"f0d7387f37c0","title":"6.&nbsp; HashMap和Hashtable将元素插入链表的方式不同：<br>&nbsp; &nbsp; &nbsp;HashMap确定加入新元素时，以尾插法将元素插入，也就是说新元素可能是链表的第一个或最后一个元素<br>&nbsp; &nbsp; &nbsp;Hashtable确定加入新元素时，以头插法将元素插入，也就是说新元素只会是链表的第一个元素"}],"collapsed":true,"id":"5f79faf41ab1","title":"细节区别"}],"collapsed":true,"id":"b5a727138d17","title":"HashMap与Hashtable的区别"},{"parent":"a47de7413880","children":[{"parent":"0675ca9d8188","children":[{"parent":"fb01d55635ad","children":[],"id":"74743efd0524","title":"1.&nbsp; HashMap是一个哈希表结构的集合容器，它是线程不安全的<br><br>2.&nbsp; HashMap底层是：数组+链表(可能树化成红黑树)+红黑树（由链表转变）的数据结构，<br>&nbsp; &nbsp;（Hash的意思是：散列表，散列表也称哈希表），因此HashMap通过拉链法解决哈希碰撞<br>&nbsp; &nbsp; &nbsp;当HashMap链表上的元素到达一定数量时，会将该链表转化为红黑树来提高效率<br><br>3.&nbsp;&nbsp;HashMap底层数据结构的实现(链表节点)：<br>&nbsp; &nbsp; &nbsp;HashMap底层实际上通过一个静态内部类Node节点来存放数据，两个存放数据的位置：<br>&nbsp; &nbsp; &nbsp;key存放元素的键，value存放元素的键值；同时该节点类中包含了一个后指针（Node类型），<br>&nbsp; &nbsp; &nbsp;用来指向该节点后面的节点；HashMap底层同时又设置了一个Node数组作为表头，每个数组元素<br>&nbsp; &nbsp; &nbsp;后都可以挂载其他的Node节点，于是数组+链表的散列表结构就形成了<br><br>4.&nbsp;&nbsp;HashMap底层数据结构的实现(红黑树节点)：<br>&nbsp; &nbsp; &nbsp;HashMap底层实际上通过一个静态内部类TreeNode节点来存放数据，TreeNode继承了<br>&nbsp; &nbsp; &nbsp;LinkedHashMap.Entry&lt;K,V&gt;，而LinkedHashMap.Entry&lt;K,V&gt;继承了HashMap.Node&lt;K,V&gt;<br>&nbsp; &nbsp; &nbsp;所以TreeNode拥有的属性有：<br>&nbsp; &nbsp; &nbsp;从父类继承下来的属性：<br>&nbsp; &nbsp; &nbsp;两个存放数据的位置：&nbsp;key存放元素的键，value存放元素的键值；<br>&nbsp; &nbsp; &nbsp;指向下一个节点的指针：next<br>&nbsp; &nbsp; &nbsp;指向上一个加入集合的元素：before ，指向下一个加入集合的元素：after<br>&nbsp; &nbsp; &nbsp;自带五个属性：红黑树父节点，左树节点，右树节点，需要断开链接的节点，是否为红色。<br>&nbsp; &nbsp; &nbsp;<br>5.&nbsp; HashMap的key和value都可以为null，key为null的元素只能有一个，value为null的元素可以多个"}],"collapsed":true,"id":"fb01d55635ad","title":"HashMap介绍"},{"parent":"0675ca9d8188","children":[{"parent":"6e20f29bd5a6","children":[],"id":"acc5e31139c1","title":"1.&nbsp; HashMap表头扩容机制：<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;1.1&nbsp; HashMap设置了一个表头扩容临界值threshold，当HashMap元素个数size超过它时<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 会对表头数组扩容2倍；<br><br>&nbsp; &nbsp; &nbsp;1.2&nbsp; 扩容临界值 = 当前表头数组容量 * 负载因子<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;1.3&nbsp; 负载因子loadFactor，不用指定负载因子构造器构造，默认是0.75<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;1.4&nbsp; 使用无参构造，默认负载因子0.75，初始表头为null<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 调用put()方法添加第一个元素，进行第一次扩容时，默认表头数组容量为16，因此<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 扩容临界值为12；HashMap元素超过12个时，扩容至32，临界值变成24，以此类推&nbsp;<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;1.5&nbsp; 调用有参构造传入指定容量时，由于表头数组的容量必须是2的次幂，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 需要通过tableSizeFor()计算出&gt;=指定容量的最小2次幂数，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 将这个值赋给扩容阈值，此时扩容阈值就代表了表头进行初始化的容量大小<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在加入第一个元素调用put()方法时，进行第一次扩容（初始化）的时候，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 会将表头数组容量扩容为扩容阈值的大小，例如：传入5---&gt;初始化为8，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后将扩容阈值更新为这个数与负载因子的乘积<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;1.6&nbsp; 当某条链表的元素个数超过TREEIFY_THRESHOLD(默认是8)，table大小没到<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MIN&nbsp;TREEIFY&nbsp;CAPACITY(默认64)，会对table扩容2倍<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;1.7&nbsp; HashMap扩容后可能会改变原来元素的索引位置，也就是可能移动链表或树<br>"},{"parent":"6e20f29bd5a6","children":[],"id":"86211bca31bb","title":"2.&nbsp; HashMap链表树化机制（红黑树）：<br>&nbsp; &nbsp; &nbsp;在Java8中,如果一条链表的元素个数超过 TREEIFY_THRESHOLD(默认是8)，<br>&nbsp; &nbsp; &nbsp;并且table的大小&gt;=MIN&nbsp;TREEIFY&nbsp;CAPACITY(默认64)，就会进行树化(红黑树)<br>&nbsp; &nbsp; &nbsp;否则采用扩容机制对表头扩容2倍"}],"collapsed":true,"id":"6e20f29bd5a6","title":"HashMap扩容和树化机制"},{"parent":"0675ca9d8188","children":[{"parent":"a6723ae135ef","children":[],"id":"955df6cc74a4","title":"1.&nbsp; 调用HashMap的put方法，put方法先对元素的<br>&nbsp; &nbsp; &nbsp;键key调用hash()方法，hash()方法调用该元素的hashCode方法，<br>&nbsp; &nbsp; &nbsp;得到hashCode值，通过算法将hashCode值转化为一个hash值，<br>&nbsp; &nbsp; &nbsp;得到hash值后会转成----&gt;该元素在table中的索引值"},{"parent":"a6723ae135ef","children":[],"id":"84973faaa3ef","title":"2.&nbsp; 然后调用putVal方法存放元素：<br>&nbsp; &nbsp; 找到存储数据表table，看这个table中这个索引位置是否已经存放有元素"},{"parent":"a6723ae135ef","children":[],"id":"720ccdee96cb","title":"3.&nbsp;&nbsp;如果没有，直接加入"},{"parent":"a6723ae135ef","children":[],"id":"f2d4a1c37cee","title":"4.&nbsp;&nbsp;如果有，说明发生了哈希碰撞：<br>&nbsp; &nbsp; &nbsp;则判断要加入的元素的键key和这个索引位置的元素的键key是否等价，及判断两个元素是否重复<br>&nbsp; &nbsp; &nbsp;判断键key等价的具体代码：<br>&nbsp; &nbsp; &nbsp;if&nbsp;(p.hash&nbsp;==&nbsp;hash&nbsp;&amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((k&nbsp;=&nbsp;p.key)&nbsp;==&nbsp;key&nbsp;||&nbsp;(key&nbsp;!=&nbsp;null&nbsp;&amp;&amp;&nbsp;key.equals(k))))<br>&nbsp; &nbsp; （注意，调用该元素的键key的equals方法时，要看该元素的键key有没有重写equals方法，如果重写了，则<br>&nbsp; &nbsp; &nbsp; &nbsp;按该元素的键key的比较方法比较内容，如果没有重写，则默认调用Object的equals方法，比较地址）<br>"},{"parent":"a6723ae135ef","children":[],"id":"2b8397368ca7","title":"5.&nbsp;&nbsp;如果不是重复的，则判断该索引位置是一条链表还是一个棵红黑树；如果重复，添加失败"},{"parent":"a6723ae135ef","children":[],"id":"eb4bb9c36c4a","title":"6.&nbsp; 如果此索引位置是一条链表：<br>&nbsp; &nbsp; &nbsp;则与该索引位置元素后面的所有元素的键key比较是否等价，如果等价，说明元素重复，就放弃添加，<br>&nbsp; &nbsp; &nbsp;如果都不发生重复，则添加到链表最后，尾插法<br>&nbsp; &nbsp; &nbsp;添加后，如果此链表元素个数超过了树化阈值8，则调用treeifyBin()方法，<br>&nbsp; &nbsp; &nbsp;treeifyBin()方法中会判断表头(table)长度是否到达64个，若没到达就对表头扩容，若到达就树化"},{"parent":"a6723ae135ef","children":[],"id":"834b6129ab77","title":"7.&nbsp; 如果此索引位置是一棵红黑树：<br>&nbsp; &nbsp; &nbsp;调用putTreeVal()方法进行添加，该方法看源码笔记"},{"parent":"a6723ae135ef","children":[],"id":"2758b25e62f9","title":"8.&nbsp;&nbsp;若添加不成功，则替换重复元素的value值，<br>&nbsp; &nbsp; &nbsp;若成功添加则HashMap元素个数size加1，加1后若达到扩容阈值，则进行扩容<br>&nbsp; &nbsp; &nbsp;扩容时，可能将原来的链表或树进行移动（他们的索引位置可能发生改变）：<br>&nbsp; &nbsp; &nbsp;每条链表或树可能在新表中以&nbsp;2&nbsp;的幂的偏移量移动"},{"parent":"a6723ae135ef","children":[],"id":"8caaa8c37acf","title":"9.&nbsp; 总结一下，也就是说：<br>&nbsp; &nbsp; 元素键key的hashCode值-&gt;hash值-&gt;表头索引位置，也就是判断有可能挂载到哪条链表或红黑树上<br>&nbsp; &nbsp; 若是链表：<br>&nbsp; &nbsp; 则通过尾插法将元素挂载到对应的这条链表上<br>&nbsp; &nbsp; 若是红黑树：<br>&nbsp; &nbsp; 调用putTreeVal()方法进行添加（具体看源码笔记）<br>"}],"collapsed":true,"id":"a6723ae135ef","title":"HashMap元素添加机制<br>&nbsp; &nbsp; &nbsp; （put方法）"}],"collapsed":true,"id":"0675ca9d8188","title":"HashMap"},{"parent":"a47de7413880","children":[{"parent":"09887ad678d2","children":[{"parent":"2ac9b5ff9b4a","children":[],"id":"95e504f0f76d","title":"1.&nbsp; 哈希表（Hashtable）又叫做散列表，是根据关键码值（即键值对）而直接访问的数据结构。<br><br>2.&nbsp; Hashtable是线程安全的，效率相比HashMap较低<br><br>3.&nbsp; Hashtable底层是：数组+链表 的数据结构，因此Hashtable通过拉链法解决哈希碰撞<br>&nbsp; &nbsp; &nbsp;与HashMap不同的是Hashtable的链表不会树化来提高效率<br><br>4.&nbsp; Hashtable底层数据结构的实现：<br>&nbsp; &nbsp; &nbsp;Hashtable底层实际上通过一个静态内部类Entry节点来存放数据，两个存放数据的位置：<br>&nbsp; &nbsp; &nbsp;key存放元素的键，value存放元素的键值；同时该节点类中包含了一个后指针（Entry类型），<br>&nbsp; &nbsp; &nbsp;用来指向该节点后面的节点；Hashtable底层同时又设置了一个Entry数组作为表头，<br>&nbsp; &nbsp; &nbsp;每个数组元素后都可以挂载其他的Entry节点，于是数组+链表的散列表结构就形成了<br><br>5.&nbsp; Hashtable的key和value都不能为null"}],"collapsed":true,"id":"2ac9b5ff9b4a","title":"Hashtable介绍"},{"parent":"09887ad678d2","children":[{"parent":"b222eb33050e","children":[],"id":"2242179e6ead","title":"Hashtable表头扩容机制：<br>&nbsp; &nbsp; &nbsp;1.&nbsp; Hashtable设置了一个表头扩容临界值threshold，当Hashtable元素个数count超过它时<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 会对表头数组扩容2倍并加1；<br>&nbsp; &nbsp; &nbsp;2.&nbsp; 扩容临界值 = 当前表头数组容量 * 扩容因子<br>&nbsp; &nbsp; &nbsp;3.&nbsp; 扩容因子loadFactor，不用指定扩容因子构造器构造，默认是0.75<br>&nbsp; &nbsp; &nbsp;4.&nbsp;&nbsp;Hashtable的构造器在构造对象时，若表头容量未指定或设置为0，会直接进行容量初始化，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 而不是在put()方法里进行，这一点和HashMap不同<br>&nbsp; &nbsp; &nbsp;5.&nbsp; 使用无参构造，默认扩容因子0.75，并在构造中进行容量初始化，表头数组容量默认扩为11<br>&nbsp; &nbsp; &nbsp;6.&nbsp; 使用有参构造，传入表头数组容量为0，并在构造中进行容量初始化，表头数组容量扩为1<br>&nbsp; &nbsp; &nbsp;7.&nbsp; 使用有参构造，传入非0的表头容量，则根据该容量进行容量初始化<br>&nbsp; &nbsp; &nbsp;8.&nbsp;&nbsp;Hashtable表头进行扩容后会改变原元素的索引值，也就是会移动原来的链表"}],"collapsed":true,"id":"b222eb33050e","title":"Hashtable扩容机制"},{"parent":"09887ad678d2","children":[{"parent":"f7bca0f8767e","children":[],"id":"a0222145151b","title":"1.&nbsp; 调用Hashtable的put()方法添加元素，<br>&nbsp; &nbsp; &nbsp;先调用要加入元素key的hashCode()方法，并作为该元素在Hashtable中的hash值，<br>&nbsp; &nbsp; &nbsp;这一点和HashMap不同，不需要对hashCode值进行处理，而是直接作为hash值，<br>&nbsp; &nbsp; &nbsp;然后根据hash值----&gt;转化为该元素在Hashtable中的索引值<br>"},{"parent":"f7bca0f8767e","children":[],"id":"eb316d2c25f0","title":"2.&nbsp; 根据该索引判断原Hashtable中该索引位置的元素，以及该元素后面的每一个元素是否与<br>&nbsp; &nbsp; &nbsp;要加入的元素是否发生重复，判断重复的方法：比较元素hash值和调用键key的equals()：<br>&nbsp; &nbsp; &nbsp;if&nbsp;((entry.hash&nbsp;==&nbsp;hash)&nbsp;&amp;&amp;&nbsp;entry.key.equals(key))"},{"parent":"f7bca0f8767e","children":[],"id":"618e1fb2f9cc","title":"3.&nbsp; 如果发生重复，则替换键值value，并返回就value对象，表明添加失败"},{"parent":"f7bca0f8767e","children":[],"id":"b08f7d63e294","title":"4.&nbsp; 如果没有发生重复，则调用addEntry(hash,&nbsp;key,&nbsp;value,&nbsp;index)，将这个元素添加到Hashtable中"},{"parent":"f7bca0f8767e","children":[],"id":"4f6c4c11f891","title":"5.&nbsp; 在addEntry()方法里：<br>&nbsp; &nbsp; &nbsp;5.1 先判断当前Hashtable元素个数count是否达到扩容阈值，如果达到，调用rehash()扩容<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;调用rehash()方法扩容时，原Hashtable元素的索引位置会变化，也就是每条链表会移动<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;所以发生扩容后要将添加的元素的索引值重新获取一遍<br>&nbsp; &nbsp; &nbsp;5.2&nbsp; 然后根据该索引（如果发生了扩容这里是已经变化了的新索引），获取该索引的原元素，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 并创建要加入元素的Entry节点将元素封装进去，然后将其next指向该索引的原元素<br>&nbsp; &nbsp; &nbsp;5.3&nbsp; 最后将该索引位置的table数组成员，table[该索引]指向要加入的这个元素，也就是将要<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 加入的元素放到目标索引的表头中<br>&nbsp; （5.2 和 5.3 相当于以头插法将元素添加到Hashtable的目标索引链表中，这与HashMap的尾插法不同）<br><br>&nbsp; &nbsp; &nbsp;5.4&nbsp; 总元素个数count加一"},{"parent":"f7bca0f8767e","children":[],"id":"b08dcfb4757b","title":"6.&nbsp; 调用addEntry()方法完成添加后，返回一个null，表明添加元素成功"}],"collapsed":true,"id":"f7bca0f8767e","title":"Hashtable元素添加机制<br>&nbsp; &nbsp; &nbsp; （put方法）"}],"collapsed":true,"id":"09887ad678d2","title":"Hashtable"},{"parent":"a47de7413880","children":[{"parent":"e135ef300925","children":[{"parent":"2661bc3a4ce8","children":[],"id":"869c4a4c5427","title":"1.&nbsp; Properties类继承自Hashtable类并且实现了Map接口，也是使用一种键值对的形式来保存数据。<br>2.&nbsp; 他的使用特点和Hashtable类似<br>3.&nbsp; Properties&nbsp;还可以用于从xxx.properties&nbsp;文件中，加载数据到Properties类对象，并进行读取和修改<br>4.&nbsp; xxx.properties文件通常作为配置文件<br>"}],"collapsed":true,"id":"2661bc3a4ce8","title":"Properties介绍"},{"parent":"e135ef300925","children":[{"parent":"d88dce463be7","children":[],"id":"72aa02b02450","title":"xxx.properties文件格式要求：<br>键=值<br>建=值<br>......<br><br>注意：键值对不需要有空格，值不需要用引号一起来。默认类型是String"},{"parent":"d88dce463be7","children":[],"id":"255847fcef59","title":"Properties对象常用方法：<br><br>1.&nbsp; load()：加载配置文件的键值对到Properties对象<br><br>2.&nbsp; list()：将数据显示到指定设备<br><br>3.&nbsp; getProperty(key)：根据键获取值<br><br>4.&nbsp; setProperty(key,value)：设置键值对到Properties对象<br><br>5.&nbsp; store()：将Properties中的键值对存储到配置文件<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (在idea中，保存信息到配置文件，如果含有中文，会存储为unicode码)<br>"}],"collapsed":true,"id":"d88dce463be7","title":"Properties使用"}],"collapsed":true,"id":"e135ef300925","title":"Properties"},{"parent":"a47de7413880","children":[{"parent":"e701b1524b60","children":[{"parent":"36c95c7a001f","children":[],"id":"0e655bc751cf","title":"1.&nbsp; LinkedHashMap是维护了一个双向链表的哈希结构集合，他继承了HashMap，是线程不安全的<br><br>2.&nbsp; LinkedHashMap的数据结构是：数组+链表+红黑树+双向链表（双向链表是LinkedHashMap的特点）<br>&nbsp; &nbsp; &nbsp;它通过继承获得了HashMap的数据结构，又独立维护了一个双向链表，来维护元素加入集合的次序<br><br>3.&nbsp; LinkedHashMap中存放元素的位置是LinkedHashMap的一个静态内部类对象Entry节点，<br>&nbsp; &nbsp; &nbsp;Entry节点是HashMap中Node节点的子节点，拥有Node节点的所有属性外，Entry节点还设置了两个指针：<br>&nbsp; &nbsp; &nbsp;前指针before和后指针after，用于指向加入该LinkedHashMap集合的上一个元素和下一个元素，<br>&nbsp; &nbsp; &nbsp;也就是说当一个元素加入到集合中时，它的before会指向上一个加入集合的元素，不管这个元素存放在哪里，<br>&nbsp; &nbsp; &nbsp;而上一个加入集合的元素的after会指向当前加入集合的这个元素，形成了一个双向链表，<br>&nbsp; &nbsp; &nbsp;从而保存了元素加入LinkedHashMap集合的顺序，这样在遍历的时候可以根据这个引导按照加入顺序取出元素，<br>&nbsp; &nbsp; &nbsp;使得LinkedHashMap的元素看起来是“有序的”，<br>&nbsp; &nbsp; &nbsp;但实际上仍是无序的，只不过通过一个双向链表记录了元素的加入顺序，也不支持索引<br><br>4.&nbsp;&nbsp;LInkedHashMap中有一个属性：accessOrder&nbsp;<br>&nbsp; &nbsp; &nbsp;决定链表的存储方式，false按照插入顺序存储，true表示按照访问(LRU)顺序存储<br>&nbsp; &nbsp; &nbsp;按访问顺序遍历：此时任何一次的操作，包括put、get操作，都会改变map中已有的存储顺序<br>&nbsp; &nbsp; &nbsp;按插入顺序遍历：只会根据元素插入集合的先后顺序进行遍历<br>&nbsp; &nbsp; &nbsp;不用指定accessOrder的构造器，默认是false，插入顺序存储，遍历时根据插入顺序遍历<br><br>"}],"collapsed":true,"id":"36c95c7a001f","title":"LinkedHashMap介绍"},{"parent":"e701b1524b60","children":[{"parent":"523d42a72f88","children":[],"id":"afbed8cc1152","title":"与HashMap相同"}],"collapsed":true,"id":"523d42a72f88","title":"LinkedHashMap扩容机制"},{"parent":"e701b1524b60","children":[{"parent":"2d52579293ee","children":[],"id":"b05605e796a6","title":"1.&nbsp; 添加步骤和HashMap一致，有两个具体细节："},{"parent":"2d52579293ee","children":[],"id":"ddacfe881391","title":"2.&nbsp; 具体细节一：<br>&nbsp; &nbsp; &nbsp;确定将元素封装到节点添加到集合中时：<br>&nbsp; &nbsp; &nbsp;HashMap调用newNode()将元素封装到Node中，或调用newTreeNode()将元素封装到TreeNode中；<br>&nbsp; &nbsp; &nbsp;LinkedHashMap重写了newNode()与newTreeNode()方法，当调用HashMap的put()方法添加元素时<br>&nbsp; &nbsp; 会通过重写的这两个方法来创建自己的节点，并调用linkNodeLast(p)方法将元素插在了双向链表尾部"},{"parent":"2d52579293ee","children":[],"id":"fa025a2b23ac","title":"3.&nbsp; 具体细节二：<br>&nbsp; &nbsp; &nbsp;HashMap中提供了三个方法，都是用来给LinkHashMap重写的，分别在访问节点，插入节点，删除节点时对链表进行维护：<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; 1.&nbsp; void&nbsp;afterNodeAccess(Node&lt;K,V&gt;&nbsp;p)&nbsp;{&nbsp;}：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;当LinkedHashMap访问(插入失败更改value的节点，被get访问到的节点)一个元素时，调用该方法<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;作用就是对accessOrder为true情况(LRU顺序)下将该节点调到末尾，尾部保存的是最近被访问的节点<br>&nbsp; &nbsp;<br>&nbsp; &nbsp; 2.&nbsp; void&nbsp;afterNodeInsertion(boolean&nbsp;evict)&nbsp;{&nbsp;}：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;当LinkedHashMap成功添加一个元素时，调用该方法，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;作用是判断是否要删除head节点(head节点最久未使用的节点)<br><br>&nbsp; &nbsp; &nbsp;3.&nbsp; void&nbsp;afterNodeRemoval(Node&lt;K,V&gt;&nbsp;p)&nbsp;{&nbsp;}：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;在移除节点操作中，其在移除节点后用afterNodeRemoval(node)将node节点的上下节点连接"}],"collapsed":true,"id":"2d52579293ee","title":"LinkedHashMap添加元素机制<br>（继承HashMap的put方法）"}],"collapsed":true,"id":"e701b1524b60","title":"LinkedHashMap"},{"parent":"a47de7413880","children":[],"id":"e670629e43f5","title":"TreeMap"}],"collapsed":true,"id":"a47de7413880","title":"Map接口实现类"}],"collapsed":true,"id":"0c6ffa9edf75","title":"Map接口"},{"parent":"67135c4f1dc0","children":[{"parent":"c0aab1899e6c","children":[],"id":"f94d0d9f2c9b","title":"在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择，分析如下：<br>1.&nbsp; 先判断存储的类型(一组对象或一组键值对)<br><br>2.&nbsp; 一组对象：Collection接口<br>&nbsp; &nbsp; 2.1 允许重复：List<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 增删多：LinkedList[底层维护了一个双向链表]<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 改查多：ArrayList&nbsp;[底层维护Object类型的可变数组]<br>&nbsp; &nbsp; 2.2 不允许重复：Set<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 无序：HashSet&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 排序：TreeSet<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 保持顺序输出：LinkedHashSet<br><br>3.&nbsp; 一组键值对：Map<br>&nbsp; &nbsp; 3.1&nbsp;键无序：HashMap&nbsp;[底层是：哈希表；&nbsp; jdk7：数组+链表；jdk8：数组+链表+红黑树]<br>&nbsp; &nbsp; 3.2 键排序：TreeMap<br>&nbsp; &nbsp; 3.3 键保持顺序：LinkedHashMap<br>&nbsp; &nbsp; 3.4 读取文件：Properties<br>"}],"collapsed":true,"id":"c0aab1899e6c","title":"集合的选择"},{"parent":"67135c4f1dc0","children":[{"parent":"14950ee7e6ed","children":[{"parent":"fba8b21a9b17","children":[],"id":"a6e9e2155ab3","title":"1.&nbsp; Collections是一个操作&nbsp;Set、List&nbsp;和&nbsp;Map&nbsp;等集合的工具类<br>2.&nbsp; Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作<br>"}],"collapsed":true,"id":"fba8b21a9b17","title":"Collections工具类介绍"},{"parent":"14950ee7e6ed","children":[{"parent":"7d76192a7730","children":[],"id":"073b48eafdd1","title":"排序操作(均为static方法)：<br>1.&nbsp; reverse(List)：反转&nbsp;List&nbsp;中元素的顺序<br>2.&nbsp; shuffle(List)： 对List集合元素进行随机排序<br>3.&nbsp; sort(List)：根据元素的自然顺序对指定List&nbsp;集合元素按升序排序<br>4.&nbsp; sort(List,&nbsp;Comparator)：根据指定的Comparator产生的顺序对&nbsp;List集合元素进行排序<br>5.&nbsp; swap(List,int,int)：将指定list集合中的i处元素和j处元素进行交换<br>"},{"parent":"7d76192a7730","children":[],"id":"62d38144bde3","title":"查找、替换(均为static方法)：<br>1.&nbsp; Object&nbsp;max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素<br>2.&nbsp; Object&nbsp;max(Collection,&nbsp;Comparator)：根据Comparator&nbsp;指定的顺序，返回给定集合中的最大元素<br>3.&nbsp; Object&nbsp;min(Collection)<br>4.&nbsp; Object&nbsp;min(Collection,Comparator)<br>5.&nbsp; int&nbsp;frequency(Collection,&nbsp;Object)：返回指定集合中指定元素的出现次数<br>6.&nbsp; void&nbsp;copy(List&nbsp;dest,List&nbsp;src)：将src中的内容复制到dest中<br>7.&nbsp; boolean&nbsp;replaceAll(List&nbsp;list,&nbsp;Object&nbsp;oldVal,&nbsp;Object&nbsp;newVal)：使用新值替换&nbsp;List&nbsp;对象的所有旧值<br>"}],"collapsed":true,"id":"7d76192a7730","title":"Collections工具类常用方法"}],"collapsed":true,"id":"14950ee7e6ed","title":"Collections工具类"}],"collapsed":false,"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#E65100","color":"#FFFFFF","textAlign":"left","font-weight":"normal","font-size":"15px","font-style":"normal","border-radius":"5px","lineStype":{"lineColor":"#666","lineWidth":2},"lineStyle":{"lineColor":"#666","lineWidth":2},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"67135c4f1dc0","title":"七、集合"},{"parent":"root","children":[{"parent":"21126ed9f251","children":[{"parent":"bfafed6399cc","children":[],"id":"0f234a9f54e1","title":"1.&nbsp; 泛型又称参数化类型，是Jdk5.0出现的新特性，解决数据类型的安全性问题<br>2.&nbsp; 在类声明或实例化时只要指定好需要的具体的类型即可<br>3.&nbsp; Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮<br>4.&nbsp; 泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型。<br>"}],"collapsed":true,"id":"bfafed6399cc","title":"泛型的介绍"},{"parent":"21126ed9f251","children":[{"parent":"618c3f588cfb","children":[{"parent":"6689bd3f19b8","children":[],"id":"5f9e5cf7e471","title":"1.&nbsp; 接口、类、抽象类都可以使用泛型，并且对泛型的使用可以有多个"},{"parent":"6689bd3f19b8","children":[],"id":"cc165b108f0c","title":"2.&nbsp; 泛型的类型在类定义的时候（创建类的引用时）就确定了，即编译期间"},{"parent":"6689bd3f19b8","children":[],"id":"90e2b598d28c","title":"3.&nbsp; 泛型只能表示引用类型"},{"parent":"6689bd3f19b8","children":[],"id":"06d21040bc08","title":"4.&nbsp; 在指定泛型的类型后，可以传入该类型或其子类型"},{"parent":"6689bd3f19b8","children":[],"id":"a3fd428fe4ea","title":"5.&nbsp; 泛型使用的一般写法：<br>&nbsp; &nbsp; &nbsp;List&lt;String&gt; list = new ArrayList&lt;String&gt;();<br>&nbsp; &nbsp; &nbsp;泛型使用的推荐写法：<br>&nbsp; &nbsp; &nbsp;List&lt;String&gt;&nbsp;list&nbsp;=&nbsp;new&nbsp;ArrayList&lt;&gt;();<br>&nbsp; &nbsp; &nbsp;这样更简洁，而且idea会自动使用推荐写法"},{"parent":"6689bd3f19b8","children":[],"id":"81aaa55d4916","title":"6.&nbsp; 如果类声明时没有传入具体泛型类型，则默认泛型为Object类型，例如：<br>&nbsp; &nbsp; &nbsp;ArrayList arr = new ArrayList();&nbsp; 等价于：<br>&nbsp; &nbsp; &nbsp;ArrayList&lt;Object&gt; arr = new ArrayList&lt;&gt;();"}],"collapsed":true,"id":"6689bd3f19b8","title":"泛型类的使用细节"},{"parent":"618c3f588cfb","children":[{"parent":"62aab6d37d17","children":[{"parent":"d78506f13ea2","children":[],"id":"5ce1e5d04802","title":"class类名&lt;T,R...&gt;&nbsp;{<br>&nbsp; T 成员<br>&nbsp; R 成员<br>}"}],"collapsed":false,"id":"d78506f13ea2","title":"基本语法"},{"parent":"62aab6d37d17","children":[{"parent":"a8f4f67623b8","children":[],"id":"c5630bf80b22","title":"1.&nbsp; 普通成员可以使用泛型（属性、方法）"},{"parent":"a8f4f67623b8","children":[],"id":"81127c3ba686","title":"2.&nbsp; 使用泛型的数组，不能初始化，因为数组不能确定数组类型的时候，无法在内存中开辟空间"},{"parent":"a8f4f67623b8","children":[],"id":"42e7137f229f","title":"3.&nbsp; 静态方法中不能使用类的泛型"},{"parent":"a8f4f67623b8","children":[],"id":"ab1423b6dd08","title":"4.&nbsp; 泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型）"},{"parent":"a8f4f67623b8","children":[],"id":"677758e1c31f","title":"5.&nbsp; 如果在创建对象时，没有指定类型，默认为Object"}],"collapsed":true,"id":"a8f4f67623b8","title":"使用细节"}],"collapsed":true,"id":"62aab6d37d17","title":"自定义泛型类"},{"parent":"618c3f588cfb","children":[{"parent":"783a6dfe9346","children":[{"parent":"aff825435e52","children":[],"id":"e810d9a29f8b","title":"interface&nbsp;接口名&lt;T,R...&gt;&nbsp;{<br>&nbsp; &nbsp; T 成员<br>&nbsp; &nbsp; R 成员<br>}"}],"collapsed":false,"id":"aff825435e52","title":"基本语法"},{"parent":"783a6dfe9346","children":[{"parent":"dbdd80ad0534","children":[],"id":"d4f6fbb20872","title":"1.&nbsp; 接口中，静态成员也不能使用泛型（这个和泛型类规定一样），<br>&nbsp; &nbsp; 注意接口的属性都是public&nbsp;static&nbsp;final的"},{"parent":"dbdd80ad0534","children":[],"id":"08012ad8f743","title":"2.&nbsp; 泛型接口的类型，在继承接口或者实现接口时确定"},{"parent":"dbdd80ad0534","children":[],"id":"b15059048c63","title":"3.&nbsp; 没有指定类型，默认为Object"}],"collapsed":true,"id":"dbdd80ad0534","title":"使用细节"}],"collapsed":true,"id":"783a6dfe9346","title":"自定义泛型接口"},{"parent":"618c3f588cfb","children":[{"parent":"f511925785d9","children":[{"parent":"626b5b51d91a","children":[],"id":"717ab6f910e5","title":"修饰符 &lt;T,R..&gt; 返回类型 方法名 (参数列表) {<br><br>}"}],"collapsed":true,"id":"626b5b51d91a","title":"基本语法"},{"parent":"f511925785d9","children":[{"parent":"090f8c7c1682","children":[],"id":"f0adec51461c","title":"1.&nbsp; 泛型方法，可以定义在普通类中，也可以定义在泛型类中"},{"parent":"090f8c7c1682","children":[],"id":"de6c98b473d2","title":"2.&nbsp; 当泛型方法被调用时，类型会确定"},{"parent":"090f8c7c1682","children":[],"id":"4c9694f30057","title":"3. 方法： public&nbsp;void&nbsp;eat(E e){ }，<br>&nbsp; &nbsp; 修饰符后没有&lt;T,R..&gt;&nbsp; ，所以eat方法不是泛型方法，而是使用了泛型"}],"collapsed":true,"id":"090f8c7c1682","title":"使用细节"}],"collapsed":true,"id":"f511925785d9","title":"自定义泛型方法"}],"collapsed":true,"id":"618c3f588cfb","title":"泛型的使用"},{"parent":"21126ed9f251","children":[{"parent":"50798320cdfa","children":[],"id":"87a1a9ba96e1","title":"从使用集合的角度："},{"parent":"50798320cdfa","children":[],"id":"fcaf9774b726","title":"1.&nbsp; 编译时，检查添加元素的类型，提高了安全性"},{"parent":"50798320cdfa","children":[],"id":"fa4e325ed462","title":"2.&nbsp; 减少了类型转换的次数，提高效率，例如：<br>&nbsp; &nbsp; &nbsp;不指定泛型：<br>&nbsp; &nbsp; &nbsp;Dog&nbsp;-加入-&gt;&nbsp;Object&nbsp;-取出-&gt;&nbsp;Dog&nbsp;//放入到ArrayList&nbsp;会先转成Object，在取出时，还需要转换成Dog<br>&nbsp; &nbsp; &nbsp;指定泛型类型：<br>&nbsp; &nbsp; &nbsp;Dog&nbsp;-&gt;&nbsp;Dog&nbsp;-&gt;&nbsp;Dog//放入时，和取出时，不需要类型转换，提高效率"},{"parent":"50798320cdfa","children":[],"id":"c8c58a81e30c","title":"3.&nbsp; 不再提示编译警告"}],"collapsed":true,"id":"50798320cdfa","title":"泛型的好处"},{"parent":"21126ed9f251","children":[{"parent":"8e5cf055b4bc","children":[],"id":"d33fbeae67a1","title":"1.&nbsp; 泛型不具备继承性，例如这样是错误的：<br>&nbsp; &nbsp; &nbsp;List&lt;Object&gt;&nbsp;list&nbsp;=&nbsp;new&nbsp;ArrayList&lt;String&gt;();"},{"parent":"8e5cf055b4bc","children":[],"id":"eab0f04dc01f","title":"2.&nbsp; &lt;?&gt;：支持任意泛型类型"},{"parent":"8e5cf055b4bc","children":[],"id":"6f37d3d632da","title":"3.&nbsp; &lt;?&nbsp;extends&nbsp;A&gt;：支持A类以及A类的子类，规定了泛型的上限"},{"parent":"8e5cf055b4bc","children":[],"id":"58a8ddf75e05","title":"4.&nbsp; &lt;?&nbsp;super&nbsp;A&gt;：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限"}],"collapsed":true,"id":"8e5cf055b4bc","title":"泛型的继承和通配符"}],"collapsed":false,"id":"21126ed9f251","title":"八、泛型"},{"parent":"root","children":[{"parent":"d74df9d8189f","children":[{"parent":"9a6150a0036e","children":[{"parent":"9208247b3350","children":[],"id":"fa7398854672","title":"1.&nbsp; 进程是指程序的一次执行，<br>&nbsp; &nbsp; 它是一个具有一定独立功能的程序对某个数据集在处理机上的一次执行过程和分配资源的基本单位，<br>&nbsp; &nbsp; 它有自身产生、存在和消亡的过程"},{"parent":"9208247b3350","children":[],"id":"3b5a3a7958a5","title":"2.&nbsp; 进程不等于程序，进程是动态的，程序是静态的，一个程序可以有多个进程在执行"}],"collapsed":true,"id":"9208247b3350","title":"什么是进程"},{"parent":"9a6150a0036e","children":[{"parent":"a4c3c089211d","children":[],"id":"3741ea90d63c","title":"1.&nbsp; 线程是由进程创建的，是进程的一个实体，是进程中实施调度和分派的基本单位"},{"parent":"a4c3c089211d","children":[],"id":"a401da1eacc8","title":"2. 现代操作系统中，进程只作为资源拥有者，而其调度和运行的属性赋予新的实体——线程"}],"collapsed":true,"id":"a4c3c089211d","title":"什么是线程"},{"parent":"9a6150a0036e","children":[{"parent":"1de51255741e","children":[],"id":"88f31ce3567e","title":"1.&nbsp; 一个进程可以有多个进程，但至少要有一个线程；<br>&nbsp; &nbsp; 并且，一个线程只能在一个进程的地址空间内活动"},{"parent":"1de51255741e","children":[],"id":"f9b40d78e494","title":"2.&nbsp; 资源分配给进程，同一进程的所有线程共享该进程的所有资源"},{"parent":"1de51255741e","children":[],"id":"2376b4b838fb","title":"3.&nbsp; 处理机分配给线程，即真正在处理机上运行的是线程"},{"parent":"1de51255741e","children":[],"id":"3e544b966607","title":"4.&nbsp; 线程在执行过程中需要协作同步。不同进程的线程间要利用消息通信的办法实现同步"}],"collapsed":true,"id":"1de51255741e","title":"线程和进程的关系"},{"parent":"9a6150a0036e","children":[{"parent":"757ca18d4d58","children":[],"id":"fe5b38350298","title":"单线程：同一时刻，只允许执行一个线程"},{"parent":"757ca18d4d58","children":[],"id":"24133103b96a","title":"多线程：同一时刻，可以执行多个线程"}],"collapsed":true,"id":"757ca18d4d58","title":"单线程与多线程"},{"parent":"9a6150a0036e","children":[{"parent":"58626de6bb89","children":[],"id":"fe4637d13b94","title":"1.&nbsp; 并发是指两个或两个以上任务在一段时间内在同一个cpu（核）上交替执行（宏观上同时）"},{"parent":"58626de6bb89","children":[],"id":"76e00b4d5958","title":"2.&nbsp; 并行是指两个或两个以上任务在同一时刻执行（真正意义上的同时）"},{"parent":"58626de6bb89","children":[],"id":"21a7693d2776","title":"3.&nbsp; 并发和并行可能同时发生"}],"collapsed":true,"id":"58626de6bb89","title":"并发与并行"}],"collapsed":true,"id":"9a6150a0036e","title":"线程介绍"},{"parent":"d74df9d8189f","children":[{"parent":"ce5bbe79e152","children":[{"parent":"a8a15b412e48","children":[],"id":"e62e8833e489","title":"1.&nbsp;&nbsp;Thread类实现了Runnable接口，实现了接口中唯一的方法run()，该方法用于执行业务代码"},{"parent":"a8a15b412e48","children":[],"id":"e9c062b76f13","title":"2.&nbsp; Thread类对象调用start()方法，线程启动后，会调用run()方法，执行业务代码"},{"parent":"a8a15b412e48","children":[],"id":"d7cb288f66a2","title":"3.&nbsp; 真正实现多线程效果的并不是run()方法，run()方法实际就是一个普通方法，只是线程启动时会调用；<br>&nbsp; &nbsp; &nbsp;而真正实现多线程效果的是start0()方法，该方法是一个本地方法，由JVM调用，底层是C/C++实现，<br>&nbsp; &nbsp; &nbsp;JVM通过调用start0()方法来调用run()方法"},{"parent":"a8a15b412e48","children":[],"id":"940ad4fbc4c1","title":"4.&nbsp; 当start()方法调用start0()方法后，该线程不一定会马上创建，start0()是本地方法，创建线程的工作是交给操作系统完成的，<br>&nbsp; &nbsp; &nbsp;Java其实本质上不能创建线程，只是给操作系统发送指令，具体线程的创建是操作系统调度决定的"},{"parent":"a8a15b412e48","children":[],"id":"370f1265844f","title":"5.&nbsp; start()方法在调用了start0()方法后，并且线程创建后，该线程不一定会马上执行，只是将线程变成可运行状态，具体<br>&nbsp; &nbsp; &nbsp;什么时候运行该线程，要看CPU的调度，这是操作系统考虑的&nbsp; &nbsp;&nbsp;"}],"collapsed":true,"id":"a8a15b412e48","title":"实现多线程的本质"},{"parent":"ce5bbe79e152","children":[{"parent":"21c858004a0f","children":[],"id":"9b87d4789a36","title":"继承Thread类，重写run()方法：<br>1.&nbsp; Thread类实现了Runnable接口，实现了run()方法<br>2.&nbsp; 当一个继承了Thread类，那么该类的对象就可以当做一个线程使用<br>3.&nbsp; 我们会在该类的run()方法上，写自己的业务代码<br>4.&nbsp; 调用该类对象的start()方法，启动线程，线程启动后JVM调用该线程的run()方法"},{"parent":"21c858004a0f","children":[],"id":"1a3f4256d39b","title":"实现Runnable接口，重写run()方法：<br>1.&nbsp; 这是推荐的创建线程的方法，原因：<br>&nbsp; &nbsp; &nbsp;java是单继承的，在某些情况下一个类可能已经继承了某个父类，这时在用继承Thread类方法来创建线程显然不可能了。<br>&nbsp; &nbsp; 并且实现Runnable接口方式更加适合多个线程共享一个资源的情况<br><br>2.&nbsp; 实现了Runnable接口的类，只是实现了run()方法，而并没有start()方法，实际上该类对象并不能真正地创建线程<br><br>3.&nbsp; Thread类有一个构造方法，根据传入Runnable接口的实现类对象，创建一个Thread对象，并且在调用该Thread对象的<br>&nbsp; &nbsp; &nbsp;run()方法时，调用的是传入的Runnable接口的实现类对象的run()方法，这里使用的是静态代理的设计模式<br><br>4.&nbsp; 因此使用方法如下：<br>&nbsp; &nbsp; &nbsp;4.1&nbsp; 创建Runnable接口的实现类<br>&nbsp; &nbsp; &nbsp;4.2&nbsp; 创建该类对象<br>&nbsp; &nbsp; &nbsp;4.3&nbsp; 根据该对象创建Thread类对象 （静态代理）<br>&nbsp; &nbsp; &nbsp;4.4&nbsp; 根据该Thread类对象调用start()方法启动线程 （静态代理）"},{"parent":"21c858004a0f","children":[],"id":"f7ba3066cd31","title":"两个方法的区别：<br>1.&nbsp; 从java的设计来看，通过继承Thread或者实现Runnable接口来创建线程本质上没有区别<br>&nbsp; &nbsp; &nbsp;从jdk帮助文档我们可以看到Thread类本身就实现了Runnable接口<br>2．实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制<br>"}],"collapsed":true,"id":"21c858004a0f","title":"创建方法"},{"parent":"ce5bbe79e152","children":[{"parent":"bb362911c543","children":[],"id":"03c51d6ed8be","title":"启动进程也就是运行代码时可以在控制台输入：JConsole，使用线程监控工具，查看线程的执行"}],"collapsed":true,"id":"bb362911c543","title":"JConsole工具"}],"collapsed":true,"id":"ce5bbe79e152","title":"线程创建"},{"parent":"d74df9d8189f","children":[{"parent":"25c3455105a6","children":[],"id":"c1b8f5a6827c","title":"1.&nbsp; 当线程完成任务后，会自动退出<br>2.&nbsp; 还可以通过使用变量来控制run方法退出的方式停止线程，即通知方式<br>"}],"collapsed":true,"id":"25c3455105a6","title":"线程终止"},{"parent":"d74df9d8189f","children":[{"parent":"3271ace3a512","children":[],"id":"d2e459b00d1c","title":"1.&nbsp; 用户线程：也叫工作线程，当线程的任务执行完或通知方式结束<br>2.&nbsp; 守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束<br>3.&nbsp; 常见的守护线程：垃圾回收机制<br>"}],"collapsed":true,"id":"3271ace3a512","title":"用户线程和守护线程"},{"parent":"d74df9d8189f","children":[{"parent":"19f416277897","children":[],"id":"6a60edd1afc9","title":"第一组：<br>1.&nbsp; setName&nbsp; &nbsp; &nbsp; //设置线程名称，使之与参数name相同<br>2.&nbsp; getName&nbsp; &nbsp; &nbsp;//返回该线程的名称<br>3.&nbsp; start&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //使该线程开始执行（Java虚拟机底层调用该线程的start0方法）<br>4.&nbsp; run&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//调用线程对象run方法<br>5.&nbsp; setPriority&nbsp; //更改线程的优先级<br>6.&nbsp; getPriority&nbsp;//获取线程的优先级<br>7.&nbsp; sleep&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//在指定的毫秒数内让当前正在执行的线程休眠（暂停执行)<br>8.&nbsp; interrupt&nbsp; &nbsp;//中断线程<br>9.&nbsp;&nbsp;currentThread&nbsp; &nbsp;//获得当前线程的引用"},{"parent":"19f416277897","children":[],"id":"54cb2c90d399","title":"第二组：<br><br>1.&nbsp; yield：线程的礼让。<br>&nbsp; &nbsp; &nbsp;让出cpu，让其他线程执行，但礼让的时间不确定，因为cpu资源可能不紧张，所以也不一定礼让成功<br><br>2.&nbsp; join：线程的插队。<br>&nbsp; &nbsp; 插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务&nbsp;&nbsp;<br><br>3.&nbsp; setDaemon：设置线程为守护线程。<br>&nbsp; &nbsp; &nbsp;一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束"}],"collapsed":true,"id":"19f416277897","title":"线程方法"},{"parent":"d74df9d8189f","children":[{"parent":"6373dc43eae9","children":[{"parent":"dcab515d359b","image":{"w":808,"h":452,"url":"http://cdn.processon.com/618fb43f7d9c08562aed7a0e?e=1636811344&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:ODZGcjEyS0l9XHhyNJFJrEea2zY="},"children":[],"id":"fd8dbc8ea45c","title":""}],"collapsed":true,"id":"dcab515d359b","title":"线程六大状态（官方文档解释）"},{"parent":"6373dc43eae9","children":[{"parent":"ddd3db0744e9","children":[],"id":"16e3e38f6c66","title":"线程七大状态：<br>New（新建）、Runnable（可运行）、Blocked（阻塞）、Waiting（无限期等待）、Time_Waiting（规定时间等待）、Terminated（死亡）<br>其中Runnable状态可细分为：Ready（就绪）、Running（正在执行）两个状态，<br>在Runnable状态中的线程处于操作系统内核态，此时线程是否运行由操作系统调度决定"},{"parent":"ddd3db0744e9","children":[{"parent":"688cd760fda0","image":{"w":900,"h":620.0314218381775,"url":"http://cdn.processon.com/618fb6d41e0853689b0d2e8f?e=1636812004&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:VpfCWMp-KRjoN60JF_-aT9ccC0o="},"children":[],"id":"8567038676c5","title":""}],"collapsed":true,"id":"688cd760fda0","title":"线程状态转换图"}],"collapsed":true,"id":"ddd3db0744e9","title":"线程七大状态（实际细化解释）"}],"collapsed":true,"id":"6373dc43eae9","title":"线程生命周期"},{"parent":"d74df9d8189f","children":[{"parent":"72f4d1e7c39c","children":[{"parent":"e0499318a067","children":[],"id":"7def1e865a3e","title":"1.&nbsp; 什么时候数据在多线程并发环境下会存在安全问题：<br>&nbsp; &nbsp; &nbsp;三个条件同时满足：1.多线程并发、2.有共享数据、3.共享数据有修改行为（光读取是不会发生安全问题的）<br>&nbsp; &nbsp; &nbsp;也就是，同一个对象被多个线程同时操作（也就是不同步操作），并对对象的数据有修改行为，<br>&nbsp; &nbsp; &nbsp;会导致数据不安全，产生紊乱的问题"},{"parent":"e0499318a067","children":[],"id":"6621cb17f9ba","title":"2.&nbsp; 在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问机制，<br>&nbsp; &nbsp; &nbsp;保证数据在任何时刻，最多有一个线程访问，以保证数据的完整性。"},{"parent":"e0499318a067","children":[],"id":"8c46e745c938","title":"3.&nbsp; 线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，<br>&nbsp; &nbsp; &nbsp;直到该线程完成操作，其他线程才能对该内存地址进行操作."}],"collapsed":true,"id":"e0499318a067","title":"线程同步机制介绍"},{"parent":"72f4d1e7c39c","children":[{"parent":"badded8d9131","children":[],"id":"2f0462a1ee8c","title":"1.&nbsp; 使用synchronized关键字：<br>&nbsp; &nbsp; &nbsp;synchronized：同步的<br>&nbsp; &nbsp; &nbsp;1.1 被synchronized关键字修饰的方法，将变成同步方法：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;public&nbsp;synchronized void eat(){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.... ....&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; &nbsp;1.2&nbsp; 被synchronized关键字修饰的代码块，将变成同步代码块：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; synchronized(对象){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .... ....<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }"},{"parent":"badded8d9131","children":[],"id":"77a1e5c39130","title":"2.&nbsp;&nbsp;synchronized原理解释：<br>&nbsp; &nbsp; 2.1&nbsp;&nbsp;在java语言中，任何一个对象都有一把互斥锁，其实这把锁就是一个标记；<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;任何一个类都有一把互斥锁，也是一个标记，不管创建几个对象，类锁只有一把<br><br>&nbsp; &nbsp; 2.2&nbsp; 当几个线程执行到一个同步方法或同步代码块时（也就是被synchronized修饰）：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;先执行到的线程（并发总会有先后）会拿到这个方法或代码块的对象锁，然后进入<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;执行代码，其他线程由于拿不到锁就开始等待，当前一个线程执行完毕，释放锁后，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;其他线程争夺此锁，拿到的进去执行，其他的排队，依次类推<br>"},{"parent":"badded8d9131","children":[],"id":"d6f3f6a14551","title":"3.&nbsp;&nbsp;synchronized使用细节：<br>&nbsp; &nbsp; &nbsp;3.1&nbsp;&nbsp;同步方法和同步代码块的对象锁，必须是线程共享的对象的锁，否则锁不住<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;3.2&nbsp;&nbsp;synchronized修饰方法时，该方法对象锁指的就是调用这个方法的对象的锁（this）<br><br>&nbsp; &nbsp; &nbsp;3.3&nbsp;&nbsp;synchronized修饰代码块时，该代码块对象锁就是括号中填入的对象的锁，因此这里<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 必须填入同步线程的共享的对象，否则每个线程都能拿到锁，无法实现同步<br><br>&nbsp; &nbsp; &nbsp;3.4&nbsp; 如果synchronized修饰的方法是静态的，则它的锁指的是这个方法的类的类锁，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果synchronized修饰的代码块处于静态方法中，则括号内应该这样写：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;synchronized(XXX.class){} 使用该静态方法的类的类锁<br>&nbsp;&nbsp;"},{"parent":"badded8d9131","children":[],"id":"88a93de38597","title":"4.&nbsp; 两种synchronized使用方法优缺点：<br>&nbsp; &nbsp; &nbsp;同步方法：<br>&nbsp; &nbsp; &nbsp;优点：如果共享的对象就是this，并且需要同步的是整个方法体，synchronized使用在实例方法上，简洁明了&nbsp;<br><br>&nbsp; &nbsp; &nbsp; 缺陷：synchronized出现在实例方法上，一定锁的是this，只能是this，不能是其他对象，所以这种方式不灵活。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 另外，synchronized出现在实例方法上，表示整个方法体都需要同步，可能会无故扩大同步范围，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 导致程序执行效率低，所以这种方式不常用<br><br>&nbsp; &nbsp; &nbsp; 同步代码块：<br>&nbsp; &nbsp; &nbsp; 优点：使用灵活，可以自由选择对象的锁，但对象必须是线程共享的对象<br><br>&nbsp; &nbsp; &nbsp; 缺陷：代码块扩得越大，效率越低，使用时需要慎重思考"}],"collapsed":true,"id":"badded8d9131","title":"使用synchronized实现同步"}],"collapsed":true,"id":"72f4d1e7c39c","title":"synchronized"},{"parent":"d74df9d8189f","children":[{"parent":"19fee23a5a54","children":[],"id":"22fe2e125fcd","title":"1.&nbsp; Java在Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。"},{"parent":"19fee23a5a54","children":[],"id":"f3eacbd3d552","title":"2.&nbsp; 每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。"},{"parent":"19fee23a5a54","children":[],"id":"a2072e153d35","title":"3.&nbsp; 关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问<br>&nbsp; &nbsp; 例如synchronized修饰代码块时，括号内的对象即被synchronized修饰，进入该代码块的线程都需要访问该对象的锁"}],"collapsed":true,"id":"19fee23a5a54","title":"互斥锁"},{"parent":"d74df9d8189f","children":[{"parent":"755b79b44372","children":[],"id":"0b35fe69f827","title":"两个或两个以上的线程占有彼此需要的资源，同时又都不愿意释放已有资源，而形成的循环等待的局面"}],"collapsed":true,"id":"755b79b44372","title":"死锁"},{"parent":"d74df9d8189f","children":[{"parent":"fc12d7a96882","children":[],"id":"af9841016711","title":"线程的以下操作会释放自己占有的锁：<br>1.&nbsp; 当前线程的同步方法、同步代码块执行结束<br><br>2.&nbsp; 当前线程在同步代码块、同步方法中遇到break、return，也导致执行结束<br><br>3.&nbsp; 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束<br><br>4.&nbsp; 当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。"},{"parent":"fc12d7a96882","children":[],"id":"c579ced45f74","title":"线程的以下操作不会释放自己占有的锁：<br>1.&nbsp; 线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行，不会释放锁<br><br>2.&nbsp; 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁。<br>&nbsp; &nbsp; &nbsp;提示：应尽量避免使用suspend()和resume() 来控制线程，方法不再推荐使用"}],"collapsed":true,"id":"fc12d7a96882","title":"释放锁"}],"id":"d74df9d8189f","title":"九、多线程基础"},{"parent":"root","children":[{"parent":"241066113afb","children":[{"parent":"72ade0e37e8b","children":[{"parent":"6dfac226b4a7","children":[],"id":"9b0ccb429f2f","title":"先创建File对象，三种方式：（父子路径都必须存在）<br>1.&nbsp; new&nbsp;File(String&nbsp;pathname)：根据路径构建一个File对象<br>2.&nbsp;&nbsp;new&nbsp;File(File&nbsp;parent,String&nbsp;child)：根据父目录对象+子路径构建<br>3.&nbsp; new&nbsp;File(String&nbsp;parent,String&nbsp;child)：根据父目录+子路径构建<br><br>再调用 .createNewFile() 方法创建文件至磁盘"}],"collapsed":true,"id":"6dfac226b4a7","title":"文件创建的三种方式"},{"parent":"72ade0e37e8b","children":[{"parent":"0dee49cd425c","children":[],"id":"9f1f6f036359","title":"1.&nbsp; 文件名字： file.getName());<br>2.&nbsp; 文件绝对路径：file.getAbsolutePath());<br>3.&nbsp; 文件父级目录：file.getParent());<br>4.&nbsp; 文件大小（字节）：file.length());<br>5.&nbsp; 文件是否存在：file.exists());<br>6.&nbsp; 是否是一个文件：file.isFile());<br>7.&nbsp; 是否是一个目录：file.isDirectory());"}],"collapsed":true,"id":"0dee49cd425c","title":"获取文件信息"},{"parent":"72ade0e37e8b","children":[{"parent":"a00ed32e1e46","children":[],"id":"f939bbcb76d5","title":"1.&nbsp; 删除文件或目录：file.delete()<br>2.&nbsp; 创建一级目录：file.mkdir()<br>3.&nbsp; 创建多级目录：file.mkdirs()"}],"collapsed":true,"id":"a00ed32e1e46","title":"目录操作"}],"collapsed":true,"id":"72ade0e37e8b","title":"文件操作"},{"parent":"241066113afb","children":[{"parent":"683ceb7f1f0c","children":[],"id":"cbb18e38e0f2","title":"1.&nbsp; 形象地来说，IO流就是负责在内存与外部设备之间传输数据的管道或是工具；<br>&nbsp; &nbsp; &nbsp;从内存中向外传出数据，称为输出流，<br>&nbsp; &nbsp; &nbsp;向内存中传入数据，称为输入流"},{"parent":"683ceb7f1f0c","children":[],"id":"268442f739c9","title":"2.&nbsp; 分类：<br>&nbsp; &nbsp; &nbsp;1. 按操作数据单位不同分为：字节流(8&nbsp;bit)，字符流(按字符)<br>&nbsp; &nbsp; &nbsp;2. 按数据流的流向不同分为：输入流，输出流<br>&nbsp; &nbsp; &nbsp;3.&nbsp;按流的角色的不同分为：节点流，处理流/包装流"},{"parent":"683ceb7f1f0c","children":[],"id":"31f2ed2ec8e8","title":"3.&nbsp; 字节流和字符流的区别与应用场景：<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;字节流：按字节的方式读取数据，一次读取一个字节byte，等同于一次读取8个二进制位<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 这种流是万能的，什么类型的文件都可以读取。包括：文本文件，图片，声音文件，视频文件等<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 但是相对于字符流来说，字节流一次只能读取一个字节，效率相比较低，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因此适用于二进制文件的读取，可以保证无损传输<br><br>&nbsp; &nbsp; &nbsp;字符流：按字符的方式读取数据，一次读取一个字符，一个字符是多少字节由编码方式决定，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Java中如何识别每一个字符并不需要程序员关心。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 字符流适合读取文本文件，效率较高，不能用来读取二进制文件，因为可能造成读取数据不完整"},{"parent":"683ceb7f1f0c","children":[{"parent":"2e8904c7df3b","children":[{"parent":"ad098acc6ba1","image":{"w":653,"h":196,"url":"http://cdn.processon.com/61a0d4bfe401fd48c0b2d57c?e=1637933776&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:-NWTtY3sTz5vJqHY-_E0ltCgW1A="},"children":[],"id":"662e90788a06","title":""}],"collapsed":true,"id":"ad098acc6ba1","title":"节点流解释图"},{"parent":"2e8904c7df3b","children":[{"parent":"1cb3ff3c5767","image":{"w":662,"h":213,"url":"http://cdn.processon.com/61a0d535e401fd48c0b2d647?e=1637933893&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:x5_AmRVmxOo-x4IEhoEPW632SKo="},"children":[],"id":"5e50bdb11fa9","title":""}],"collapsed":true,"id":"1cb3ff3c5767","title":"节点/处理流分类"}],"collapsed":false,"id":"2e8904c7df3b","title":"4.&nbsp; 节点流和处理流（包装流）的区别和解释：<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;1．节点流可以从一个特定的数据源读写数据，如FileReader、FileWriter&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;节点流是低级流，比较底层，直接跟数据源相接，灵活性和功能有限<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;2.&nbsp; 处理流（也叫包装流）是“连接”在已存在的流（节点流或处理流）之上，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 为程序提供更为强大的读写功能，也更加灵活，如BufferedReader、BufferedWriter<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 处理流实际上就是对节点流的封装、装饰，底层维护了一个节点流对象<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 这样的设计模式称为：装饰者模式<br><br>&nbsp; &nbsp; &nbsp;3.&nbsp; 处理流的好处：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1．性能的提高：主要以增加缓冲的方式来提高输入输出的效率。&nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.&nbsp; &nbsp;操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;使用更加灵活方便<br><br>"}],"collapsed":true,"id":"683ceb7f1f0c","title":"IO流概述"},{"parent":"241066113afb","children":[{"parent":"da304976017e","children":[],"id":"901dbf7949f4","title":"四大抽象基类：<br>1.&nbsp; InputStream：字节输入流<br>2.&nbsp; OutputStream：字节输出流<br>3.&nbsp; Reader：字符输入流<br>4.&nbsp; Writer：字符输出流"},{"parent":"da304976017e","children":[],"id":"bd8e863eecb0","title":"1)&nbsp; Java的IO流共涉及40多个类，实际上非常规则，都是从如上4个抽象基类派生的<br>2)&nbsp; 由这四个类派生出来的子类名称都是以其父类名作为子类名后缀"}],"collapsed":true,"id":"da304976017e","title":"四大基类"},{"parent":"241066113afb","children":[{"parent":"b1b750b77f7d","children":[{"parent":"01797ed186cc","children":[{"parent":"f5b4c70b61cd","children":[{"parent":"50700aacae4d","children":[{"parent":"1bf0ee87777d","children":[],"id":"3dfb15d57489","title":"1.&nbsp; 根据路径读取文件：FileInputStream(String&nbsp;name)<br>2.&nbsp; 读取传入的文件对象：FileInputStream(File&nbsp;file)"}],"collapsed":true,"id":"1bf0ee87777d","title":"构造方法"},{"parent":"50700aacae4d","children":[{"parent":"bbc596f00c3b","children":[],"id":"a54748e3a2c8","title":"1.&nbsp; read() 方法读取：<br>&nbsp; &nbsp; &nbsp;每次读取一个字节，并返回该字节(int类型，ASCII码)<br>&nbsp; &nbsp; &nbsp;若要输出，可强转为char类型（char和int之间可以直接转换）<br>&nbsp; &nbsp; &nbsp;若读取结束，返回-1<br><br>2.&nbsp; read(byte[]&nbsp;buff) 方法读取：<br>&nbsp; &nbsp; &nbsp;一次读取一个字节数组，读到该数组中<br>&nbsp; &nbsp; &nbsp;正常读取，返回实际读到的字节个数<br>&nbsp; &nbsp; &nbsp;读取完毕，返回-1<br>&nbsp; &nbsp; &nbsp;若要输出，可根据该数组构建String对象，调用String类型的<br>&nbsp; &nbsp; &nbsp;构造方法：String(byte&nbsp;bytes[],&nbsp;int&nbsp;offset,&nbsp;int&nbsp;length)"}],"collapsed":true,"id":"bbc596f00c3b","title":"读取方式"}],"collapsed":true,"id":"50700aacae4d","title":"FileInputStream"},{"parent":"f5b4c70b61cd","children":[{"parent":"c7518acb8aab","children":[{"parent":"5f26b056d414","children":[],"id":"711970efcc0c","title":"1.&nbsp;&nbsp;根据路径写入文件：FileOutputStream(String&nbsp;name,&nbsp;boolean&nbsp;append)<br>2.&nbsp; 写入传入的文件对象：FileOutputStream(File&nbsp;file,&nbsp;boolean&nbsp;append)<br>&nbsp; &nbsp;&nbsp;<br>说明：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.&nbsp; 如果文件不存在，会默认创建（但路径必须存在）<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.&nbsp; 不传入追加方式append的值，默认为false，不追加，直接覆盖<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;注意，并不是每调用一次write()就覆盖一次，而是流关闭前的所有操作作为一个整体覆盖一次<br>"}],"collapsed":true,"id":"5f26b056d414","title":"构造方法"},{"parent":"c7518acb8aab","children":[{"parent":"c2ae29284107","children":[],"id":"27306fb8a344","title":"1.&nbsp; 写入一个字节：write(int&nbsp;b)<br><br>2.&nbsp;&nbsp;写入字符串：write(byte&nbsp;b[])<br>&nbsp; &nbsp; &nbsp;可以使用字符串的getBytes()方法：将字符串转换为byte数组传入<br><br>3.&nbsp;&nbsp;写入byte数组中的指定内容：write(byte&nbsp;b[],&nbsp;int&nbsp;off,&nbsp;int&nbsp;len)<br>&nbsp; &nbsp; &nbsp;可以使用字符串的getBytes()方法：将字符串转换为byte数组传入"}],"collapsed":true,"id":"c2ae29284107","title":"写入方式"}],"collapsed":true,"id":"c7518acb8aab","title":"FileOutPutStream"},{"parent":"f5b4c70b61cd","children":[{"parent":"5c64e368c3fc","children":[{"parent":"67baf946cdb9","children":[],"id":"c6cd1f4cfe30","title":"new&nbsp;FileReader(File/String)"}],"collapsed":true,"id":"67baf946cdb9","title":"构造方法"},{"parent":"5c64e368c3fc","children":[{"parent":"bc611a963451","children":[],"id":"c6a2e09dba55","title":"1.&nbsp; read()：每次读取单个字符，返回该字符，如果到文件末尾返回-1<br>2.&nbsp; read(char[])：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1<br>&nbsp; &nbsp; &nbsp;相关API:<br>&nbsp; &nbsp; &nbsp;1）new&nbsp;String(char)：将char[]转换成String<br>&nbsp; &nbsp; &nbsp;2）String(char[], off,&nbsp;len)：将char[]的指定部分转换成String<br>"}],"collapsed":true,"id":"bc611a963451","title":"读取方式"}],"collapsed":true,"id":"5c64e368c3fc","title":"FileReader"},{"parent":"f5b4c70b61cd","children":[{"parent":"5f60d88dc88f","children":[{"parent":"91dc05582560","children":[],"id":"600505c48db5","title":"1)&nbsp;new&nbsp;FileWriter(File/String)：覆盖模式，相当于流的指针在首端"}],"collapsed":true,"id":"91dc05582560","title":"构造方法"},{"parent":"5f60d88dc88f","children":[{"parent":"6a827a34509c","children":[],"id":"eb208f431569","title":"1)&nbsp;write(int)：写入单个字符<br>2)&nbsp;write(char[])：写入指定数组<br>3)&nbsp;write(char[],off,len)：写入指定数组的指定部分<br>4)&nbsp;write&nbsp;(string)：写入整个字符串<br>5)&nbsp;write(string,off,len)：写入字符串的指定部分<br><br>相关API:&nbsp;<br>String类：toCharArray:将String转换成char[]<br><br>注意:<br>FileWriter使用后，必须要关闭(close)或刷新(flush)，否则写入不到指定的文件!<br>原因：调用close或flush方法，底层才执行真正将数据写入磁盘的操作"}],"collapsed":true,"id":"6a827a34509c","title":"读取方式"}],"collapsed":true,"id":"5f60d88dc88f","title":"FileWriter"}],"collapsed":true,"id":"f5b4c70b61cd","title":"文件File操作流"}],"collapsed":true,"id":"01797ed186cc","title":"节点流"},{"parent":"b1b750b77f7d","children":[{"parent":"6311c88bce50","children":[{"parent":"37f4b27db248","children":[{"parent":"65443e71e2a3","children":[{"parent":"c8a68e1c1492","children":[],"id":"00cfffdd2d52","title":"传入字节输入流类型的节点流：BufferedInputStream(InputStream&nbsp;in)"}],"id":"c8a68e1c1492","title":"构造方法"},{"parent":"65443e71e2a3","children":[{"parent":"2e8b15bc7e04","children":[],"id":"f823dc123a56","title":"一般直接用所包装的节点流的方法"}],"id":"2e8b15bc7e04","title":"常用方法"}],"collapsed":true,"id":"65443e71e2a3","title":"BufferedInputStream"},{"parent":"37f4b27db248","children":[{"parent":"abf0bf97bf9e","children":[{"parent":"a4da94037388","children":[],"id":"0aaba42aa35d","title":"传入字节输出流类型的节点流：BufferedOutputStream(OutputStream&nbsp;out)"}],"collapsed":false,"id":"a4da94037388","title":"构造方法"},{"parent":"abf0bf97bf9e","children":[{"parent":"317e6eeadd11","children":[],"id":"7e46fdbee44a","title":"一般直接用所包装的节点流的方法"}],"id":"317e6eeadd11","title":"常用方法"}],"collapsed":true,"id":"abf0bf97bf9e","title":"BufferedOutputStream"},{"parent":"37f4b27db248","children":[{"parent":"e84922406756","children":[{"parent":"2d615f3dfa79","children":[],"id":"a711b70b5321","title":"传入字符输入流类型的节点流：BufferedReader(Reader&nbsp;in)"}],"id":"2d615f3dfa79","title":"构造方法"},{"parent":"e84922406756","children":[{"parent":"ff47f698bba4","children":[],"id":"0445be1c5a4a","title":"1.&nbsp; readLine() ：读一行文本<br>2.&nbsp; skip()：跳过n个字符再继续读取"}],"id":"ff47f698bba4","title":"常用方法"}],"collapsed":true,"id":"e84922406756","title":"BufferedReader"},{"parent":"37f4b27db248","children":[{"parent":"1fda01edc7a1","children":[{"parent":"902e44822866","children":[],"id":"9059e9c94948","title":"传入字符输出流类型的节点流：BufferedWriter(Writer&nbsp;out)"}],"id":"902e44822866","title":"构造方法"},{"parent":"1fda01edc7a1","children":[{"parent":"fc218190224b","children":[],"id":"4fa3545b8ec5","title":"1.&nbsp;&nbsp;newLine()：插入一个换行符<br>2.&nbsp;&nbsp;write(String&nbsp;str)：直接写入一行字符串"}],"id":"fc218190224b","title":"常用方法"}],"collapsed":true,"id":"1fda01edc7a1","title":"BufferedWriter"}],"collapsed":true,"id":"37f4b27db248","title":"缓冲流"},{"parent":"6311c88bce50","children":[{"parent":"e40dd05574d5","children":[{"parent":"e825120a7984","children":[],"id":"f754d524c307","title":"1.&nbsp; 对象流的作用：<br>&nbsp; &nbsp; &nbsp;对象流可以将一个对象存储到文件中，保存对象的状态，称为序列化<br>&nbsp; &nbsp; &nbsp;相对地可以将对象从文件中读出，恢复对象的状态，称为反序列化<br>"},{"parent":"e825120a7984","children":[],"id":"882272f51853","title":"2.&nbsp; 序列化和反序列化：<br>&nbsp; &nbsp; &nbsp;序列化：Serialize&nbsp; 对java对象进行拆分，按序列号拆分成若干数据包，存储到文件中。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;将java对象的状态保存下来的过程（文件是dat文件）<br>&nbsp; &nbsp; 反序列化：DeSerialize&nbsp;将硬盘中的数据按序列号组装，重新恢复到内存当中，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;恢复成java对象的过程<br><br>&nbsp; &nbsp; 序列化需要类(流)：ObjectOutputStream&nbsp;方法：writeObject();<br>&nbsp; &nbsp; 反序列化需要类(流)：ObjectInputStream&nbsp;方法：readObject();"},{"parent":"e825120a7984","children":[],"id":"1f19202d7285","title":"3.&nbsp; 序列化细节：<br>&nbsp; &nbsp; 3.1&nbsp; 参与序列化和反序列化的对象，其类必须实现Serializable接口或Externalizable接口；<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;一般使用Serializable接口，它是一个标记接口，没有方法来需要实现<br>&nbsp; &nbsp; <br>&nbsp; &nbsp; 3.2&nbsp; 参与序列化和反序列化的对象，其类都必须有一个序列化版本号。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;解释：java中区分类的方式是：1.根据类名的不同&nbsp;2.类名相同根据序列化版本号进行区分<br><br>&nbsp; &nbsp; 3.3&nbsp; 实现了Serializable接口后，可以不用手动写类的序列化版本号，jvm会自动为其分配一个<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;独一无二的版本号，这样做虽然方便，但有一个重大缺陷：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;当一个类没有手动写序列化版本号时，若对象序列化之后，修改了类的内容，那么重新编<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;译时，该类的序列化版本号会被jvm重新分配，导致和之前的不同，那么文件中的对象就<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;无法再反序列化回来<br><br>&nbsp; &nbsp; 3.4&nbsp; 手动写一个独一无二的序列化版本号很重要，提高版本兼容性<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Idea中快捷键生成一个序列化版本号：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 鼠标放在类名上按alt+回车，选择创建一个序列化版本号<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; 3.5&nbsp; 对于基本数据类型的序列化和反序列化，会先将基本类型进行自动装箱成包装类对象，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;基本类型的包装类对象都实现了Serializable接口<br><br>&nbsp; &nbsp; 3.6&nbsp; 序列化对象时，默认将里面所有属性都进行序列化，但除了static或transient修饰的成员<br><br>&nbsp; &nbsp; 3.7&nbsp; 序列化对象时,要求里面属性的类型也需要实现序列化接口<br>&nbsp;<br>&nbsp; &nbsp; 3.8&nbsp; 序列化具备可继承性，如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化<br><br>"}],"collapsed":true,"id":"e825120a7984","title":"对象流解释"},{"parent":"e40dd05574d5","children":[{"parent":"e36b9a3cf07b","children":[{"parent":"faf7019d7b04","children":[{"parent":"a39315a702f4","children":[],"id":"7d025dd687cc","title":"传入字节输入流类型的节点流：<br>ObjectInputStream(InputStream&nbsp;in)<br>"}],"id":"a39315a702f4","title":"构造方法"},{"parent":"faf7019d7b04","children":[{"parent":"f8c7255b71e4","children":[],"id":"fb5151768e76","title":"反序列化对象：readObject();"}],"id":"f8c7255b71e4","title":"使用方法"}],"collapsed":true,"id":"faf7019d7b04","title":"ObjectInputStream"},{"parent":"e36b9a3cf07b","children":[{"parent":"f06be703dcbd","children":[{"parent":"d1bd77dd18cd","children":[],"id":"8762f47d7edf","title":"传入字节输出流类型的节点流：<br>ObjectOutputStream(OutputStream&nbsp;out)<br>"}],"id":"d1bd77dd18cd","title":"构造方法"},{"parent":"f06be703dcbd","children":[{"parent":"604ea21e9218","children":[],"id":"6725a43ef56b","title":"序列化对象：writeObject();<br>"}],"id":"604ea21e9218","title":"使用方法"}],"collapsed":true,"id":"f06be703dcbd","title":"ObjectOutputStream"}],"collapsed":true,"id":"e36b9a3cf07b","title":"对象流使用"}],"collapsed":true,"id":"e40dd05574d5","title":"对象流"},{"parent":"6311c88bce50","children":[{"parent":"811a0a1d5661","children":[{"parent":"3835229e8ebb","children":[],"id":"dd38f4d18bc3","title":"当我们使用字符流对文本文件进行读取的时候，默认是utf-8的编码方式读取，当读取的文件编码方式不符时，<br>读取的中文等信息可能出现乱码问题，于是我们引出了转换流：<br>用转换流可以指定编码方式，将传入的字节流转换为字符流，完成对文本的读取，有效解决中文乱码问题<br>同时，使用转换流进行写文件，可以根据指定的编码方式写入<br>"}],"collapsed":true,"id":"3835229e8ebb","title":"转换流的引出"},{"parent":"811a0a1d5661","children":[{"parent":"f8dfedc4ef4a","children":[{"parent":"63e15eefeed7","children":[],"id":"96d4ec41cf27","title":"传入字节输入流和编码方式：<br>InputStreamReader(InputStream&nbsp;in,&nbsp;String&nbsp;charsetName)<br>"}],"collapsed":true,"id":"63e15eefeed7","title":"构造方法"},{"parent":"f8dfedc4ef4a","children":[{"parent":"fb68bd340e80","children":[],"id":"8856ba43d898","title":"1.&nbsp; 传入字节输入流，构造一个字符转换流：<br>&nbsp; &nbsp; &nbsp;new&nbsp;InputStreamReader(new&nbsp;FileInputStream(path),\"gbk\");<br><br>2.&nbsp; 将转换流包装成一个字符缓冲流：<br>&nbsp; &nbsp; &nbsp;br&nbsp;=&nbsp;new&nbsp;BufferedReader(isr);<br><br>3.&nbsp; 使用字符缓冲流进行读取：<br>&nbsp; &nbsp; &nbsp;br.readLine()；<br><br>"}],"collapsed":true,"id":"fb68bd340e80","title":"使用方法"}],"collapsed":true,"id":"f8dfedc4ef4a","title":"InputStreamReader"},{"parent":"811a0a1d5661","children":[{"parent":"0e4c35d4a0a2","children":[{"parent":"527a3ba74f8d","children":[],"id":"5414439fb1e7","title":"传入字节输出流和编码方式：<br>OutputStreamWriter(OutputStream&nbsp;out,&nbsp;String&nbsp;charsetName)"}],"collapsed":true,"id":"527a3ba74f8d","title":"构造方法"},{"parent":"0e4c35d4a0a2","children":[{"parent":"2fc67e080772","children":[],"id":"071b043028f2","title":"1.&nbsp; 传入字节输出流构造字符转换流<br>2.&nbsp; 将转换流包装成字符缓冲流<br><br>合起来写：<br>BufferedWriter&nbsp;bw&nbsp;=new&nbsp;BufferedWriter(new&nbsp;OutputStreamWriter(new&nbsp;FileOutputStream(path),\"gbk\"));<br><br>"}],"collapsed":true,"id":"2fc67e080772","title":"使用方法"}],"collapsed":true,"id":"0e4c35d4a0a2","title":"OutputStreamWriter"}],"collapsed":true,"id":"811a0a1d5661","title":"转换流"},{"parent":"6311c88bce50","children":[{"parent":"48c2cb1a3070","children":[{"parent":"e5d817d26afc","children":[],"id":"2b47e50a0ec7","title":"1.&nbsp; 打印流只有输出流，字节打印流和字符打印流；<br>2.&nbsp; PrintStream是基类InputStream的实现子类，<br>&nbsp; &nbsp; &nbsp;PrintWriter是基类Writer的实现子类；<br>3.&nbsp; PrintStream不需要手动关闭，PrintWriter需要<br>4.&nbsp; System类中的输入输出流被称为标准输入输出<br>&nbsp; &nbsp; &nbsp;而其输出流就是PintStream，字节打印流<br>&nbsp; &nbsp; &nbsp;其输入流是BufferedInputStream，字节缓冲流"}],"collapsed":true,"id":"e5d817d26afc","title":"打印流解释以及和标准流的关系"},{"parent":"48c2cb1a3070","children":[{"parent":"1cdfa41e8e4e","children":[{"parent":"1bac083f57ad","children":[{"parent":"2b6e5e2aa42c","children":[],"id":"45f9200392dc","title":"1.&nbsp; 默认打印到屏幕：<br>&nbsp; &nbsp; &nbsp;PrintStream&nbsp;ps&nbsp;=&nbsp;System.out;&nbsp;<br>&nbsp; &nbsp; &nbsp;//System.out返回的是一个PrintStream的对象"},{"parent":"2b6e5e2aa42c","children":[],"id":"c8e78c7595ad","title":"2.&nbsp; 指定打印到的文件：<br>&nbsp; &nbsp; &nbsp;new&nbsp;PrintStream(new&nbsp;FileOutputStream(path));<br><br>3.&nbsp; 指定文件和字符集：<br>&nbsp; &nbsp; &nbsp;PrintStream(File&nbsp;file,&nbsp;String&nbsp;csn)"}],"collapsed":true,"id":"2b6e5e2aa42c","title":"构造方法"},{"parent":"1bac083f57ad","children":[{"parent":"95b5229e2880","children":[],"id":"12c45d83a89b","title":"print(String&nbsp;s) ：打印一个字符串<br>println(String&nbsp;x)：打印并换行<br>"}],"collapsed":true,"id":"95b5229e2880","title":"使用方法"}],"collapsed":true,"id":"1bac083f57ad","title":"字节打印流：<br>PrintStream<br>"},{"parent":"1cdfa41e8e4e","children":[{"parent":"7d06ebcf7a78","children":[{"parent":"30ba747adf2a","children":[],"id":"4087e5bbadfc","title":"传入字节流：PrintWriter(OutputStream&nbsp;out)<br>传入字符流：PrintWriter(Writer&nbsp;out)<br>指定文件和字符集：PrintWriter(File&nbsp;file,&nbsp;String&nbsp;csn)<br>"}],"collapsed":true,"id":"30ba747adf2a","title":"构造方法"},{"parent":"7d06ebcf7a78","children":[{"parent":"d19c23278bad","children":[],"id":"460da7d22b28","title":"print(String&nbsp;s) ：打印一个字符串<br>println(String&nbsp;x)：打印并换行"}],"collapsed":true,"id":"d19c23278bad","title":"使用方法"}],"collapsed":true,"id":"7d06ebcf7a78","title":"字符打印流：<br>PrintWriter<br>"}],"collapsed":true,"id":"1cdfa41e8e4e","title":"打印流实现类<br>"}],"collapsed":true,"id":"48c2cb1a3070","title":"打印流"},{"parent":"6311c88bce50","children":[{"parent":"238b54c24517","children":[],"id":"d47d68355a19","title":"System类中属性：public&nbsp;final&nbsp;static&nbsp;InputStream&nbsp;in&nbsp;=&nbsp;null;<br>&nbsp; System.in&nbsp;的编译类型：InputStream<br>&nbsp; System.in&nbsp;的运行类型：BufferedInputStream<br>&nbsp; 表示的是，标准输入：&nbsp;键盘"},{"parent":"238b54c24517","children":[],"id":"bcef876819b9","title":"System类中属性：public&nbsp;final&nbsp;static&nbsp;PrintStream&nbsp;out&nbsp;=&nbsp;null;<br>&nbsp; &nbsp;System.out&nbsp;的编译类型：PrintStream<br>&nbsp; &nbsp;System.out&nbsp;的运行类型：PrintStream<br>&nbsp; &nbsp;表示的是，标准输出：&nbsp;显示器<br>&nbsp; &nbsp;PrintStream中的println()方法将信息打印到显示器<br><br>&nbsp; &nbsp;调用：System.setOut(PrintStream);修改标准输出的位置，<br>&nbsp; &nbsp;根据传入的打印流PrintStream决定输出的位置，可以是文件<br>&nbsp; &nbsp;根据这个方法，可以制作一个日志打印工具"}],"collapsed":true,"id":"238b54c24517","title":"标准输入输出流"}],"collapsed":true,"id":"6311c88bce50","title":"处理流"}],"collapsed":true,"id":"b1b750b77f7d","title":"常用的实现子类"}],"id":"241066113afb","title":"十、IO"},{"parent":"root","children":[{"parent":"0889502f5ce2","children":[{"parent":"871883d440a9","children":[{"parent":"bc4cf7e48197","children":[],"id":"a1896a2fcda3","title":"1.&nbsp; 通过反射可以根据外部文件的配置来控制程序，而不需要修改源代码，体现了OCP：开闭原则<br><br>2.&nbsp; 根据反射机制才有了web框架的实现，反射是web框架的灵魂（框架 = 注解 + 反射 +设计模式）"}],"collapsed":true,"id":"bc4cf7e48197","title":"反射机制的意义"},{"parent":"871883d440a9","children":[{"parent":"44aa9d54d35b","children":[],"id":"f520d96aa92e","title":"解释：<br>1．反射机制允许程序在执行期借助于反射相关API取得任何类的内部信息(比如成员变量，构造器，成员方法等等)，<br>&nbsp; &nbsp; &nbsp;并能操作对象的属性及方法。反射在设计模式和框架底层都会用到<br><br>2.&nbsp; 加载完类之后，在堆中就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象包含了类的完整结构信息。<br>&nbsp; &nbsp; 通过这个对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，形象的称之为：反射"},{"parent":"44aa9d54d35b","children":[{"parent":"e9c4d2ab575a","children":[{"parent":"5a242e146173","image":{"w":900,"h":406.6162570888469,"url":"http://cdn.processon.com/61df2e9707912973ef207b11?e=1642020007&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:YOZFlA9P5tNMRrk2WSTIhgWPBRY="},"children":[],"id":"7ff1ea8acc34","title":""}],"collapsed":true,"id":"5a242e146173","title":"图解"}],"collapsed":true,"id":"e9c4d2ab575a","title":"java程序在计算机中的三个阶段：<br>代码阶段（编译阶段）：<br>先从java文件按成员变量，构造方法，成员方法通过javac编译成class文件<br><br>Class类阶段（加载阶段）：<br>通过类加载器把class文件中的成员变量，构造方法，成员方法加载到内存中<br>此处体现了反射<br><br>Runtime运行阶段：<br>该阶段进行对象创建和对象方法的调用<br>"}],"collapsed":true,"id":"44aa9d54d35b","title":"反射机制的原理"},{"parent":"871883d440a9","children":[{"parent":"e5722dd36b7c","children":[],"id":"17fa48919738","title":"1.&nbsp; java.lang.Class：代表一个类，Class对象表示某个类加载后在堆中的对象<br>"},{"parent":"e5722dd36b7c","children":[],"id":"912feb9fb5cd","title":"2.&nbsp; java.lang.reflect.Method：代表类的方法,&nbsp;Method对象表示某个类的方法<br>"},{"parent":"e5722dd36b7c","children":[],"id":"a130da9e9d10","title":"3.&nbsp; java.lang.reflect.Field：代表类的成员变量,&nbsp;Field对象表示某个类的成员变量<br>"},{"parent":"e5722dd36b7c","children":[],"id":"a185fce48d4c","title":"4.&nbsp; java.lang.reflect.Constructor：代表类的构造方法,Constructor对象表示构造器"}],"collapsed":true,"id":"e5722dd36b7c","title":"反射相关的主要类"},{"parent":"871883d440a9","children":[{"parent":"f8c5532e267e","children":[],"id":"d1318636f0e1","title":"反射的优点与缺点：<br>1.&nbsp; 优点：可以动态的创建和使用对象(也是框架底层核心)，使用灵活，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;没有反射机制，框架技术就失去底层支撑<br>2.&nbsp; 缺点：使用反射基本是解释执行,对执行速度有影响<br>"},{"parent":"f8c5532e267e","children":[],"id":"2e613d271c81","title":"优化---关闭访问权限（效果不算高）：<br>1.&nbsp; Method和Field、Constructor对象都有setAccessible()方法<br>2.&nbsp; setAccessible作用是启动和禁用访问安全检查的开关<br>3.&nbsp; 参数值为true表示反射的对象在使用时取消访问检查，提高反射的效率<br>&nbsp; &nbsp; &nbsp;参数值为false则表示反射的对象执行访问检查<br>"}],"collapsed":true,"id":"f8c5532e267e","title":"反射调用优化"}],"collapsed":true,"id":"871883d440a9","title":"反射机制"},{"parent":"0889502f5ce2","children":[{"parent":"bc7b27eb4c83","children":[{"parent":"af7eeb205454","children":[],"id":"8c6f500b1bb5","title":"1.&nbsp; Class也是类，因此也继承Object类<br><br>2.&nbsp; Class类对象不是new出来的，而是系统创建的<br><br>3.&nbsp; 对于某个类的Class类对象，在内存中只有一份，因为类只加载一次<br><br>4.&nbsp; 每个类的实例都会记得自己是由哪个Class实例所生成<br><br>5.&nbsp; 通过Class对象的一系列API可以完整地得到一个类的完整结构<br><br>6.&nbsp; Class对象是存放在堆的<br><br>7. 类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据<br>&nbsp; &nbsp;(包括方法代码,变量名，方法名，访问权限等等)&nbsp;<br>"}],"collapsed":true,"id":"af7eeb205454","title":"基本介绍"},{"parent":"bc7b27eb4c83","children":[{"parent":"f82239a87e1e","children":[],"id":"ecaaa3f8af6a","title":"1.&nbsp; 外部类,成员内部类,静态内部类,局部内部类，匿名内部类<br>2.&nbsp; interface:接口<br>3.&nbsp; 数组<br>4.&nbsp; 枚举<br>5.&nbsp; 注解<br>6.&nbsp; 基本数据类型<br>7.&nbsp; void"}],"collapsed":true,"id":"f82239a87e1e","title":"有Class类对象的所有类型"},{"parent":"bc7b27eb4c83","children":[{"parent":"aa5574981cbb","children":[],"id":"cc4b1f8209a3","title":"1．前提：已知一个类的全类名，且该类在类路径下，<br>&nbsp; &nbsp; &nbsp;可通过Class类的静态方法Class.forName()获取<br>&nbsp; &nbsp; &nbsp;应用场景：多用于配置文件，读取类全路径，加载类"},{"parent":"aa5574981cbb","children":[],"id":"48cca538b548","title":"2．前提：已知具体的类，通过 类.class 获取，该方式最为安全可靠，程序性能最高<br>&nbsp; &nbsp; &nbsp;应用场景：多用于参数传递，比如通过反射得到对应构造器对象"},{"parent":"aa5574981cbb","children":[],"id":"a61cc3e425ee","title":"3.&nbsp; 前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象<br>&nbsp; &nbsp; &nbsp;应用场景:通过创建好的对象，获取Class对象."},{"parent":"aa5574981cbb","children":[],"id":"8fadf6951a46","title":"4.&nbsp; 其他方式：根据某个类的实例获取类加载器，通过类加载器获取Class对象<br>&nbsp; &nbsp; ClassLoader&nbsp;cl&nbsp;=对象.getClass().getClassLoaderO;<br>&nbsp; &nbsp; Class&nbsp;cls&nbsp;=&nbsp;cl.loadClass(类的全类名);"},{"parent":"aa5574981cbb","children":[],"id":"72de32c5a7bb","title":"5．基本数据(int,&nbsp;char,boolean,float,double,byte,long,short)按如下方式得到Class类对象：<br>&nbsp; &nbsp; &nbsp;Class&nbsp;cls&nbsp;= 基本数据类型.class"},{"parent":"aa5574981cbb","children":[],"id":"366bf7574e65","title":"6.&nbsp; 基本数据类型对应的包装类，可以通过.TYPE得到Class类对象：<br>&nbsp; &nbsp; &nbsp;Class&nbsp;cls&nbsp;= 包装类.TYPE"}],"collapsed":true,"id":"aa5574981cbb","title":"获取Class类对象的六种方法"},{"parent":"bc7b27eb4c83","children":[{"parent":"ac521a16a823","children":[],"id":"8731f37918cb","title":"1.&nbsp; 根据全类名获取Class对象：Class.forName(全类名)<br>2.&nbsp; 根据Class对象创建对应类的对象实例：cls.newInstance()<br><br>获取类结构信息：<br>1.&nbsp; getName：获取全类名<br>2.&nbsp; getSimpleName：获取简单类名<br>3.&nbsp; getFields：获取所有public修饰的属性，包含本类以及父类的<br>4.&nbsp; getDeclaredFields：获取本类中所有属性<br>5.&nbsp; getMethods：获取所有public修饰的方法，包含本类以及父类的<br>6.&nbsp; getDeclaredMethods：获取本类中所有方法<br>7.&nbsp; getConstructors：获取本类所有public修饰的构造器<br>8.&nbsp; getDeclaredConstructors：获取本类中所有构造器<br>9.&nbsp; getPackage：以Package形式返回包信息<br>10.&nbsp; getSuperClass：以Class形式返回父类信息<br>11.&nbsp; getlnterfaces：以Classl[ ] 形式返回接口信息<br>12.&nbsp; getAnnotations：以Annotationl[ ] 形式返回注解信息<br><br>java.lang.reflect.Field类：<br>1.&nbsp; getModifiers： 以int形式返回修饰符<br>&nbsp; &nbsp;（说明：默认修饰符是0，public是1，&nbsp;private是2，protected是4<br>&nbsp; &nbsp; &nbsp; &nbsp;static是8，final&nbsp;是&nbsp;16，例如： public(1)&nbsp;+&nbsp;static&nbsp;(8)= 9）<br>2.&nbsp; getType：Class形式返回类型<br>3.&nbsp; getName：返回属性名<br><br>java.lang.reflect.Method类：<br>1.&nbsp; getModifiers：以int形式返回修饰符<br>&nbsp; （说明：默认修饰符是0，&nbsp;public是1，private是2，protected是4<br>&nbsp; &nbsp; &nbsp; static是8，final是16）<br>2.&nbsp; getReturnType：以Class形式获取返回类型<br>3.&nbsp; getName：返回方法名<br>4.&nbsp; getParameterTypes：以Class[ ]返回参数类型数组<br><br>java.lang.reflect.&nbsp;Constructor类：<br>1.&nbsp; getModifiers：以int形式返回修饰符<br>2.&nbsp; getName：返回构造器名（全类名）<br>3.&nbsp; getParameterTypes：以Class[ ]返回参数类型数组<br>"}],"collapsed":true,"id":"ac521a16a823","title":"Class类对象常用API"}],"collapsed":true,"id":"bc7b27eb4c83","title":"Class类"},{"parent":"0889502f5ce2","children":[{"parent":"b48fc913d31c","children":[{"parent":"57a431641e19","children":[],"id":"4177b362fd7a","title":"1.&nbsp; 方式一：调用类中的public修饰的无参构造器：<br>&nbsp; &nbsp; 直接调用Class对象的newInstance()方法，默认<br>&nbsp; &nbsp; 调用类中public修饰的无参构造器创建对象"},{"parent":"57a431641e19","children":[],"id":"54ce845fab52","title":"2. 方式二：调用类中的指定构造器（暴破创建）：<br>&nbsp; &nbsp; 1）先通过Class对象获取指定构造器，相关方法：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getConstructor(Class...clazz)：根据参数列表，获取对应的public构造器对象<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getDecalaredConstructor(Class...clazz)：根据参数列表，获取对应的所有构造器对象<br>&nbsp; &nbsp; 2）再通过构造器对象创建实例，相关方法：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;setAccessible()：暴破<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;newlnstance(Object...obj)：调用构造器<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果构造器是私有的，则先调用构造器对象的setAccessible()方法暴破，使得私有构造<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;也可以访问"}],"collapsed":true,"id":"57a431641e19","title":"反射暴破创建实例"},{"parent":"b48fc913d31c","children":[{"parent":"bbad84ad526e","children":[],"id":"a6ecd8fa5879","title":"1．根据属性名获取Field对象：<br>&nbsp; &nbsp; &nbsp;Field&nbsp;f&nbsp;=&nbsp;clazz对象.getDeclaredField(属性名)<br>2.&nbsp;&nbsp;获取对象：Object&nbsp;o=clazz.newlnstance();<br>3.&nbsp; 暴破：f.setAccessible(true);//f是Field，使得私有属性也能访问<br>4.&nbsp; 访问：修改属性值：f.set(o,值);//o表示对象<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 获取属性值：f.get(o);//o表示对象<br>5. &nbsp;注意：如果是静态属性，则set和get中的参数o，可以写成null<br>"}],"collapsed":true,"id":"bbad84ad526e","title":"反射暴破操作属性"},{"parent":"b48fc913d31c","children":[{"parent":"cf547df3fa09","children":[],"id":"7becee6d5354","title":"1.&nbsp; 根据方法名和参数列表获取Method方法对象：<br>&nbsp; &nbsp; &nbsp;Method&nbsp;m&nbsp;=clazz.getDeclaredMethod(方法名，XX.class);&nbsp;//得到本类的所有方法&nbsp;<br>2.&nbsp; 获取对象：Object&nbsp;o=clazz.newlnstance();<br>3.&nbsp; 暴破：m.setAccessible(true); //m是method，使得私有方法也能调用<br>4.&nbsp; 访问：Object&nbsp;returnValue&nbsp;=&nbsp;m.invoke(o,实参列表); //o就是对象&nbsp;<br>5.&nbsp; 注意：如果是静态方法，则invoke的参数o，&nbsp;可以写成null"}],"collapsed":true,"id":"cf547df3fa09","title":"反射暴破操作方法"}],"collapsed":true,"id":"b48fc913d31c","title":"反射暴破"}],"collapsed":false,"id":"0889502f5ce2","title":"十一、反射"},{"parent":"root","children":[{"parent":"c8f2c7ac1b13","children":[{"parent":"e9504054f703","children":[{"parent":"588ea1cd0a21","children":[],"id":"ee0e78fa347a","title":"这个类代表一个互联网协议（IP）地址，通过它可获得ip、主机名称，等信息"}],"collapsed":true,"id":"588ea1cd0a21","title":"解释"},{"parent":"e9504054f703","children":[{"parent":"c40ede98a989","children":[],"id":"85082a737415","title":"静态方法：<br>1.&nbsp; getLocalHost()：获取本机InetAddress对象getLocalHost<br>2.&nbsp;&nbsp;getByName()：根据指定主机名/域名获取ip地址对象"},{"parent":"c40ede98a989","children":[],"id":"c3ee6db9f55e","title":"对象方法：<br>3.&nbsp; getHostName()：获取InetAddress对象的主机名<br>4.&nbsp; getHostAddress()：获取InetAddress对象的地址"}],"collapsed":true,"id":"c40ede98a989","title":"常用方法"}],"collapsed":true,"id":"e9504054f703","title":"InetAddress"},{"parent":"c8f2c7ac1b13","children":[{"parent":"f4233c37b345","children":[{"parent":"9dd9b96f9b15","children":[],"id":"b328bca35c75","title":"1.&nbsp; 套接字(Socket)开发网络应用程序被广泛采用，以至于成为事实上的标准<br>2.&nbsp; 通信的两端都要有Socket，是两台机器间通信的端点<br>3.&nbsp; 网络通信其实就是Socket间的通信<br>4.&nbsp; Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输<br>5.&nbsp; 一般主动发起通信的应用程序属客户端，等待通信请求的为服务端<br>"}],"collapsed":true,"id":"9dd9b96f9b15","title":"解释"},{"parent":"f4233c37b345","children":[{"parent":"451b06be8190","children":[{"parent":"11d76ba8c921","children":[{"parent":"bdf7fc98bfba","children":[],"id":"844836401374","title":"1.&nbsp; 使用TCP协议前，须先建立TCP连接，形成传输数据通道<br>2.&nbsp; 传输前，采用“三次握手\"方式，是可靠的<br>3.&nbsp; TCP协议进行通信的两个应用进程：客户端、服务端<br>4.&nbsp; 在连接中，创建io流数据通道，可进行大数据量的传输<br>5.&nbsp; 传输完毕，需释放已建立的连接，效率低<br>6.&nbsp; 基于的套接字：Socket和SeverSocket"}],"collapsed":true,"id":"bdf7fc98bfba","title":"TCP协议"},{"parent":"11d76ba8c921","children":[{"parent":"d0d38ff02a53","children":[],"id":"eb2fcae6669a","title":"1.&nbsp; 构造socket对象（建立Socket连接）：<br><br>&nbsp; &nbsp; &nbsp;客户端：new Socket(ip，端口)<br><br>&nbsp; &nbsp; &nbsp;服务端：<br>&nbsp; &nbsp; &nbsp;先构造ServerSocket对象（创建ServerSocket连接）：new ServerSocket(监听的端口号)<br>&nbsp; &nbsp; &nbsp;再通过ServerSocket对象的accept()方法，返回socket连接，此处阻塞等待客户端访问端口<br><br>"},{"parent":"d0d38ff02a53","children":[],"id":"b0a649164e80","title":"2.&nbsp; 创建数据通道（IO流）：<br><br>&nbsp; &nbsp; &nbsp;2.1&nbsp; 字节流：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 输入流：socket.getInputStream()<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 输出流：socket.getOutputStream()<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 输出完毕后，设置结束标志，否则对方无法识别是否结束发送，而不断阻塞等待：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; socket.shutdownOutput();<br><br>&nbsp; &nbsp; &nbsp;2.2&nbsp; 字符流：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 输入流：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 先创建字节流：InputStream&nbsp;inputStream&nbsp;=&nbsp;socket.getInputStream();<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 通过转换流进行转换：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferedReader&nbsp;br&nbsp;=&nbsp;new&nbsp;BufferedReader(new&nbsp;InputStreamReader(inputStream));<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 输出流：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 先创建字节流：OutputStream&nbsp;outputStream&nbsp;=&nbsp;socket.getOutputStream();<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 通过转换流进行转换：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferedWriter&nbsp;bw&nbsp;=&nbsp;new&nbsp;BufferedWriter(new&nbsp;OutputStreamWriter(outputStream));<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 输出完毕后，设置结束标志，否则对方无法识别是否结束发送，而不断阻塞等待：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; socket.shutdownOutput();<br><br>"}],"collapsed":true,"id":"d0d38ff02a53","title":"常用方法"}],"collapsed":true,"id":"11d76ba8c921","title":"TCP"},{"parent":"451b06be8190","children":[{"parent":"29d7027495e0","children":[{"parent":"4ecaa74341f8","children":[],"id":"e75d47567148","title":"1.&nbsp; 没有明确的服务端和客户端，演变成数据的两个端口互相发送和接收，不需要建立连接，故是不可靠的<br>2.&nbsp; 接收数据和发送数据是通过&nbsp;DatagramSocket对象完成<br>3.&nbsp; 将数据封装到DatagramPacket&nbsp;对象/装包，每个数据包的大小限制在64K内<br>4.&nbsp; 当接收到&nbsp;DatagramPacket&nbsp;对象，需要进行拆包，取出数据<br>5.&nbsp; DatagramSocket可以指定在哪个端口接收数据<br>6.&nbsp; 发送数据结束时无需释放资源(因为不是面向连接的)，速度快<br>7.&nbsp; 基于的套接字：DatagramSocket、DatagramPacket"}],"collapsed":true,"id":"4ecaa74341f8","title":"UDP协议"},{"parent":"29d7027495e0","children":[{"parent":"35ec1a16bd5a","children":[],"id":"0b5e98a199aa","title":"1.&nbsp; 构造DatagramSocke对象（DatagramSocke连接）：<br>&nbsp; &nbsp; &nbsp;接收端和发送端都是：<br>&nbsp; &nbsp; &nbsp;new&nbsp;DatagramSocket(接收和发送数据的端口号)；<br>"},{"parent":"35ec1a16bd5a","children":[],"id":"81d2dadbdff5","title":"2.&nbsp; 数据发送和接收：<br>&nbsp; &nbsp; &nbsp;2.1 收包：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.&nbsp; 创建一个DatagramPacket对象，准备收取数据包：DatagramPacket(byte&nbsp;buf[],&nbsp;int&nbsp;length)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.&nbsp; 调用DatagramSocket对象的接收方法receive(packet)，收取一个数据包，装包&nbsp;&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.&nbsp; 拆包，将数据展示出来：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; packet.getLength()：数据包中的数据长度<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; packet.getData()：整个数据包（字节数组）<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new&nbsp;String(data,0,length)：数据包（字节数组）转化成String<br><br>&nbsp; &nbsp; &nbsp;2.2 发包：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.&nbsp; 创建一个DatagramPacket对象，准备发送数据包：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatagramPacket(byte&nbsp;buf[],&nbsp;int&nbsp;length,&nbsp;InetAddress&nbsp;address,&nbsp;int&nbsp;port)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 传入数组、长度、接收方的ip地址和端口号<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.&nbsp; 调用DatagramSocket对象的发送方法： socket.send(packet2)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>"}],"collapsed":true,"id":"35ec1a16bd5a","title":"常用方法"}],"collapsed":true,"id":"29d7027495e0","title":"UDP"}],"collapsed":true,"id":"451b06be8190","title":"基于Socket的网络编程"}],"collapsed":true,"id":"f4233c37b345","title":"Socket"}],"collapsed":false,"id":"c8f2c7ac1b13","title":"十二、网络通信"}],"root":true,"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#E65100","color":"#FFFFFF","textAlign":"left","font-weight":"normal","font-size":"15px","font-style":"normal","border-radius":"5px","lineStype":{"lineColor":"#666","lineWidth":2},"lineStyle":{"lineColor":"#666","lineWidth":2},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"theme":"customise_6f4c68ca0c69","id":"root","title":"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Java基础学习总结<br>&nbsp; （主要根据B站韩顺平视频学习所总结）<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;（老韩牛逼！！！）","version":473,"structure":"mind_right"}},"meta":{"exportTime":"2022-10-21 00:36:02","member":"60a4a6f9e0b34d34ca68de2e","diagramInfo":{"creator":"60a4a6f9e0b34d34ca68de2e","created":"2021-09-29 14:01:26","modified":"2022-10-20 23:50:53","title":"Java基础学习总结","category":"mind_free"},"id":"61540136e0b34d09123248e8","type":"ProcessOn Schema File","version":"1.0"}}